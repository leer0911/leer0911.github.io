<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[nginx]]></title>
    <url>%2F2017%2F10%2F18%2Fnginx%2F</url>
    <content type="text"><![CDATA[Nginx（发音同engine x）是一个网页服务器，它能反向代理HTTP, HTTPS, SMTP, POP3, IMAP的协议链接，以及一个负载均衡器和一个HTTP缓存。 反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 nginxNginx（发音同engine x）是一个网页服务器，它能反向代理HTTP, HTTPS, SMTP, POP3, IMAP的协议链接，以及一个负载均衡器和一个HTTP缓存。 起初是供俄国大型的门户网站及搜索引擎Rambler（俄语：Рамблер）使用。此软件BSD-like协议下发行，可以在UNIX、GNU/Linux、BSD、Mac OS X、Solaris，以及Microsoft Windows等操作系统中运行。 特点Nginx是一款面向性能设计的HTTP服务器，相较于Apache、lighttpd具有占有内存少，稳定性高等优势。与旧版本（&lt;=2.2）的Apache不同，nginx不采用每客户机一线程的设计模型，而是充分使用异步逻辑，削减了上下文调度开销，所以并发服务能力更强。整体采用模块化设计，有丰富的模块库和第三方模块库，配置灵活。 在Linux操作系统下，nginx使用epoll事件模型，得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于epoll的高效事件模型kqueue。 官方站点也指出了Nginx作为HTTP服务器的几项基本特性： 处理静态文件，索引文件以及自动索引；打开文件描述符缓冲 无缓存的反向代理加速，简单的负载均衡和容错 FastCGI，简单的负载均衡和容错 模块化的结构，包括gzipping,byte ranges,chunked responses,以及SSI-filter等filter。 支持SSL和TLSSNI. 可大量平行处理Nginx在官方测试的结果中，能够支持五万个平行连接，而在实际的运作中，是可以支持二万至四万个平行链接。 nginx 的模块整体采用模块化设计是nginx的一个重大特点，甚至http服务器核心功能也是一个模块。要注意的是：nginx的模块是静态的，添加和删除模块都要对nginx进行重新编译，这一点与Apache的动态模块完全不同。也就意味着通过二进制包安装方式（如apt-get，yum，Deb，RPM）安装的nginx软件是无法添加/删除模块的。 什么是反向代理反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 有反向代理，当然也存在正向代理的概念咯。正向代理指的是，一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。 所谓的正向代理就是代理服务器替代访问方【用户A】去访问目标服务器【服务器B】，在现实中的例子就是『翻墙』！但如果代理服务器Z被完全控制（或不完全控制），就变成了『肉鸡』了。 而反向代理与正向代理相反，对客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间（name-space）中的内容发送普通请求，接着反向代理将判断向何处（原始服务器）转交请求，并将获得的内容返回给客户端。 负载均衡当反向代理服务器不止一个的时候，我们甚至可以把它们做成集群，当更多的用户访问资源服务器B的时候，让不同的代理服务器Z（x）去应答不同的用户，然后发送不同用户需要的资源。 当然反向代理服务器像正向代理服务器一样拥有CACHE的作用，它可以缓存原始资源服务器B的资源，而不是每次都要向原始资源服务器B请求数据，特别是一些静态的数据，比如图片和文件，如果这些反向代理服务器能够做到和用户X来自同一个网络，那么用户X访问反向代理服务器X，就会得到很高质量的速度。这正是CDN技术的核心。 使用mac 环境下 12345brew search nginxbrew install nginxnginx 配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332######Nginx配置文件nginx.conf中文详解######定义Nginx运行的用户和用户组user www www;#nginx进程数，建议设置为等于CPU总核心数。worker_processes 8; #全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]error_log /usr/local/nginx/logs/error.log info;#进程pid文件pid /usr/local/nginx/logs/nginx.pid;#指定进程可以打开的最大描述符：数目#工作模式与连接数上限#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。#现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。worker_rlimit_nofile 65535;events&#123; #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型 #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。 #补充说明： #与apache相类，nginx针对不同的操作系统，有不同的事件模型 #A）标准事件模型 #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll #B）高效事件模型 #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。 #Epoll：使用于Linux内核2.6版本及以后的系统。 #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。 #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。 use epoll; #单个进程最大连接数（最大连接数=连接数*进程数） #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。 worker_connections 65535; #keepalive超时时间。 keepalive_timeout 60; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。 #分页大小可以用命令getconf PAGESIZE 取得。 #[root@web001 ~]# getconf PAGESIZE #4096 #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。 client_header_buffer_size 4k; #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。 open_file_cache max=65535 inactive=60s; #这个是指多长时间检查一次缓存的有效信息。 #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息. open_file_cache_valid 80s; #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。 #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location 这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态. open_file_cache_min_uses 1; #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误. open_file_cache_errors on;&#125; #设定http服务器，利用它的反向代理功能提供负载均衡支持http&#123; #文件扩展名与文件类型映射表 include mime.types; #默认文件类型 default_type application/octet-stream; #默认编码 #charset utf-8; #服务器名字的hash表大小 #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小. server_names_hash_bucket_size 128; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。 client_header_buffer_size 32k; #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。 large_client_header_buffers 4 64k; #设定通过nginx上传文件的大小 client_max_body_size 8m; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。 #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。 sendfile on; #开启目录列表访问，合适下载服务器，默认关闭。 autoindex on; #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用 tcp_nopush on; tcp_nodelay on; #长连接超时时间，单位是秒 keepalive_timeout 120; #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。 fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; #gzip模块设置 gzip on; #开启gzip压缩输出 gzip_min_length 1k; #最小压缩文件大小 gzip_buffers 4 16k; #压缩缓冲区 gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0） gzip_comp_level 2; #压缩等级 gzip_types text/plain application/x-javascript text/css application/xml; #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。 gzip_vary on; #开启限制IP连接数的时候需要使用 #limit_zone crawler $binary_remote_addr 10m; #负载均衡配置 upstream piao.jd.com &#123; #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。 server 192.168.80.121:80 weight=3; server 192.168.80.122:80 weight=2; server 192.168.80.123:80 weight=3; #nginx的upstream目前支持4种方式的分配 #1、轮询（默认） #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 #2、weight #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 #例如： #upstream bakend &#123; # server 192.168.0.14 weight=10; # server 192.168.0.15 weight=10; #&#125; #2、ip_hash #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 #例如： #upstream bakend &#123; # ip_hash; # server 192.168.0.14:88; # server 192.168.0.15:80; #&#125; #3、fair（第三方） #按后端服务器的响应时间来分配请求，响应时间短的优先分配。 #upstream backend &#123; # server server1; # server server2; # fair; #&#125; #4、url_hash（第三方） #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法 #upstream backend &#123; # server squid1:3128; # server squid2:3128; # hash $request_uri; # hash_method crc32; #&#125; #tips: #upstream bakend&#123;#定义负载均衡设备的Ip及设备状态&#125;&#123; # ip_hash; # server 127.0.0.1:9090 down; # server 127.0.0.1:8080 weight=2; # server 127.0.0.1:6060; # server 127.0.0.1:7070 backup; #&#125; #在需要使用负载均衡的server中增加 proxy_pass http://bakend/; #每个设备的状态设置为: #1.down表示单前的server暂时不参与负载 #2.weight为weight越大，负载的权重就越大。 #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误 #4.fail_timeout:max_fails次失败后，暂停的时间。 #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。 #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。 #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug #client_body_temp_path设置记录文件的目录 可以设置最多3层目录 #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡 &#125; #虚拟主机的配置 server &#123; #监听端口 listen 80; #域名可以有多个，用空格隔开 server_name www.jd.com jd.com; index index.html index.htm index.php; root /data/www/jd; #对******进行负载均衡 location ~ .*.(php|php5)?$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; &#125; #图片缓存时间设置 location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 10d; &#125; #JS和CSS缓存时间设置 location ~ .*.(js|css)?$ &#123; expires 1h; &#125; #日志格式设定 #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址； #$remote_user：用来记录客户端用户名称； #$time_local： 用来记录访问时间与时区； #$request： 用来记录请求的url与http协议； #$status： 用来记录请求状态；成功是200， #$body_bytes_sent ：记录发送给客户端文件主体内容大小； #$http_referer：用来记录从那个页面链接访问过来的； #$http_user_agent：记录客户浏览器的相关信息； #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。 log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;; #定义本虚拟主机的访问日志 access_log /usr/local/nginx/logs/host.access.log main; access_log /usr/local/nginx/logs/host.access.404.log log404; #对 &quot;/&quot; 启用反向代理 location / &#123; proxy_pass http://127.0.0.1:88; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #以下是一些反向代理的配置，可选。 proxy_set_header Host $host; #允许客户端请求的最大单文件字节数 client_max_body_size 10m; #缓冲区代理缓冲用户端请求的最大字节数， #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。 #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误 client_body_buffer_size 128k; #表示使nginx阻止HTTP应答代码为400或者更高的应答。 proxy_intercept_errors on; #后端服务器连接的超时时间_发起握手等候响应超时时间 #nginx跟后端服务器连接超时时间(代理连接超时) proxy_connect_timeout 90; #后端服务器数据回传时间(代理发送超时) #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据 proxy_send_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间） proxy_read_timeout 90; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小 proxy_buffer_size 4k; #proxy_buffers缓冲区，网页平均在32k以下的设置 #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k proxy_buffers 4 32k; #高负荷下缓冲大小（proxy_buffers*2） proxy_busy_buffers_size 64k; #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长 #设定缓存文件夹大小，大于这个值，将从upstream服务器传 proxy_temp_file_write_size 64k; &#125; #设定查看Nginx状态的地址 location /NginxStatus &#123; stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file confpasswd; #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。 &#125; #本地动静分离反向代理配置 #所有jsp的页面均交由tomcat或resin处理 location ~ .(jsp|jspx|do)?$ &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; &#125; #所有静态文件由nginx直接读取不经过tomcat或resin location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt| pdf|xls|mp3|wma)$ &#123; expires 15d; &#125; location ~ .*.(js|css)?$ &#123; expires 1h; &#125; &#125;&#125;######Nginx配置文件nginx.conf中文详解#####]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于vue的简单流程图开发]]></title>
    <url>%2F2017%2F10%2F16%2F%E5%9F%BA%E4%BA%8Evue%E7%9A%84%E7%AE%80%E5%8D%95%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[严重拖延症，一方面这项目模块纯属个人娱乐。另一方面，流程图这块涉及的东西还是蛮多的，这次也只是介绍一些简单的部分。拖了这么久，现在终于要开始硬着头皮写一篇基于vue+svg的流程图”伪教程”文章了。初次献丑，还请轻喷。 模块简介项目地址 出于学习vue而非兼容的目的，本项目仅考虑现代浏览器( 谷歌 )，部分兼容问题还请见谅。 本模块的开发源于对流程图的简单需求( 纯UI实现，暂不存在业务逻辑 )，这里不赘诉vue-cli生成的目录结构(可以参考这篇或自行谷歌)。 项目实际用到的技术栈：SVG + vue + vuex 功能介绍： 画布缩放 节点( 开始,基础,判断等 )添加，删除 节点间连线( 直线/折线 ) 文本添加 外部导入SVG图形 撤销与重做 画布缩放考虑到画布缩放后布局需保持一致，这里通过修改transform: scale(); transform-origin: ; 来实现,节点则相对父层定位。 TODO: SVG最优缩放解决方案? 节点相关下面我简单说一下思路： 由于不存在业务逻辑，我把流程图简化为 开始 基础 判断 3个基础组件( 基于SVG )。 如: 12345678&lt;template&gt; &lt;!-- 开始 --&gt; &lt;ellipse v-bind="style"&gt;&lt;/ellipse&gt; &lt;!-- 基础 --&gt; &lt;rect v-bind="style"&gt;&lt;/rect&gt; &lt;!-- 判断 --&gt; &lt;path v-bind="style"&gt;&lt;/path&gt;&lt;/template&gt; 这里说一下判断这个组件( 后期可能出现复杂形状均以path实现 )，一般由AI软件直接导出相关形状。 左边工具栏跟画布中的相同图形源于同个组件，故设有两个样式，即 defaultStyle 和 drawStyle。之前有考虑过，如果流程图的图形复杂多变的话，那这种模式岂不是每一个组件都得人为定义。同样，采用导入SVG也有类似问题。因为如果图形大小都不确定的话，除了支持图形修改大小，否者将导致画布出现大小不一的图形。( 非常遗憾这方面没有做出突破，不过这将成为未来改进的方向。) 最开始采用的解决方案是以scale的方式，也就是统一让工具栏中的图形跟拖入画布中的图形成等比缩放关系。不过该方式会造成stroke也同比缩放，并非我们想要的。 所以目前暂时采用写死的方式。 注意: 在svg中 ellipse 定位相对于中心点，而rect定位是相对于左上角。 TODO是否有办法将各组件定位源点设置为组件中心点。 节点渲染节点渲染方面，由于之前是将图形作为组件，于是采用 component + is 的方式来渲染图形。同时也是以数据驱动的方式来渲染，即数据决定视图。 1&lt;component v-for="(item,index) in nodeData" :is="item.type" :id="item.id" v-node inDraw&gt;&lt;/component&gt; 拖动节点涉及镜像节点时： 1&lt;component :is="selNodeId" :transform="selNodeInfo.transform" v-if="isDragging" inDraw&gt;&lt;/component&gt; 代码直通车 新增节点drag drop 的形式。采用该方式的好处是不需要模拟拖拽事件。也就是镜像什么的不需要自己做。( 画布内节点拖拽则使用原生模拟 ) 代码直通车 对节点的操作均以指令( directives )的形式( 直接操作DOM )。这引发了我对该类项目是否适合用vue类框架来做的疑问，从开发效率方面，还是首选vue，但是从性能方面，由于没有深入研究，并没有发言权。 TODO 场景模拟，假设我们需要移动画布内节点，通过directives的el来获取节点，然后通过el.onmousemove来修改data中对应的translate来实现位置的更改。这里修改data来驱动视图是我们常用的方式，但是我想不通的就是el.onmousemove来修改data实现的双向数据绑定所带来的性能在这里是否有体现。 我所设想的是，是否涉及多依赖的时候，diff带来的性能提升才有价值。举个例子，我有一个列表，存在于data中的listData，然后在view中有多处关联listData。那此时操作listData比直接操作DOM来得更好些。 看过相关vitrualDOM的介绍，通过diff可以只操作变化的DOM。 获取SVG大小获取节点大小使用 getBoundingClientRect ，同时由于前面做了缩放功能，这里获取节点大小时需要除以缩放比例来获取正确值。 1234567let obj = el.getElementsByTagName('g')[0]let w = obj.getBoundingClientRect().width / _this.drawStyle.zoomRatelet h = obj.getBoundingClientRect().height / _this.drawStyle.zoomRatelet wh = &#123; width: w, height: h&#125; 代码直通车 节点操作总结由于节点的显示是基于NodeData，所以增删其实就是对NodeData的增删。 主要代码 连线相关连线其实也只是用到了svg的line和polyline，这里跟节点类似，均以组件的形式存在，并以lineData驱动连线视图。所以最终连线的增删也是对数据的操作。 连接点的显示 首先是链接点的位置( 绿色远点位置 )，之前基于jquery做的流程图是用div布局，现在用svg增加了难度，由于svg不能使用position，所以无法基于当前元素定位。采用的是土办法，即用图形大小+padding动态获取4个点的位置。期间，由于4个连线节点与图形节点有空隙，当mouseover不处于图形或节点时，事件无法触发。在此是模拟一个区域来解决的。由于个人经验问题，这部分代码完全就是命令式的风格。勿喷 代码直通车代码直通车2 连接处理节点间连线做了两种情况：（这里不讲诉从mousedown至mouseup具体细节，可以看这里） 其实很多人说，算法可以解决很多垃圾代码。可惜我还没掌握它的真谛，比如之前的图形组件，以及接下来的不同线条。其实都可以通过一定的算法得出来。我这里只讲讲最笨的方法，待我成长到能用算法来说话的时候，在回来好好理下这篇文章。 line直线 直线无外乎就是两个点坐标，通过svg中的line来显示。这时候就得看项目的需求，我们假设最简单的情况，就是上面讲到过的4个连接点最为连线的起始或结束点。下面是计算图形中4个点的坐标位置 1234567891011121314151617181920212223computeLine(direction, obj) &#123; // low不止一点点 let &#123; top, left, width, height &#125; = obj let w = width / 2 let h = height / 2 switch (direction) &#123; case 't': top = top - h break case 'b': top = top + h break case 'l': left = left - w break case 'r': left = left + w break default: break &#125; return &#123; top, left &#125;&#125; polyline折线 折线考虑的情况相对比较多一点，这边由于使用的是polyline，它的点位设置长这样子points=&quot;125,96 183.5,96 183.5,399 242,399&quot; 这个时候一般会把字符转化为较为好操作的数组或对象。折线涉及的开始点跟结束点跟上面介绍直线的点位一样，不同的是中间线的位置，如果不考虑复杂的情况， 一般可以分为两种，上下，左右。通过获取开始与结束点的中点位置来确定中线即可以得到想要的折线。代码如下：（都是用简单粗暴的方式。） 12345678910111213141516171819202122232425262728293031323334353637383940computePolyLine(start, end, direction) &#123; let startPoint = &#123; x: +(start.split(',')[0]), y: +(start.split(',')[1]) &#125; let endPoint = &#123; x: +(end.split(',')[0]), y: +(end.split(',')[1]) &#125; let m1, m2 switch (direction) &#123; case 't': case 'b': let mY = startPoint.y + (endPoint.y - startPoint.y) / 2 m1 = &#123; x: startPoint.x, y: mY &#125; m2 = &#123; x: endPoint.x, y: mY &#125; break case 'l': case 'r': let mX = startPoint.x + (endPoint.x - startPoint.x) / 2 m1 = &#123; x: mX, y: startPoint.y &#125; m2 = &#123; x: mX, y: endPoint.y &#125; break default: break &#125; return `$&#123;startPoint.x&#125;,$&#123;startPoint.y&#125; $&#123;m1.x&#125;,$&#123;m1.y&#125; $&#123;m2.x&#125;,$&#123;m2.y&#125; $&#123;endPoint.x&#125;,$&#123;endPoint.y&#125;`&#125; 连线总结节点跟连线在渲染以及操作的处理上大同小异，这里不确定是否为最佳实践的有两个地方，一是采用component+is的形式来渲染组件，二是采用 diretives的方式来操作DOM。连线的计算形式也略显简单，这确实是需要一定时间来成长的。扯偏了，在这简单总结一下，无论是哪种连线方式，我们需要做的就是正确获取对应点的位置，然后修改数据来驱动视图。不过能在各种复杂的情况下总结出算法，也是一种跨越，加油吧。 节点及连线的文本添加节点及连线的文本添加原理都一样，这里采用的是设置 contenteditable 当contenteditable为true时，html结构自动添加文本节点并且可编辑。更多细节可以参考张鑫旭的这篇 顺道讲一下pointer-events本模块有两个地方用到该css属性。一个是文本添加这块，以及头部工具栏部分。 CSS属性pointer-events允许作者控制特定的图形元素在何时成为鼠标事件的target。当未指定该属性时，SVG内容表现如同visiblePainted。 除了指定元素不成为鼠标事件的目标，none值还指示鼠标事件穿过该元素，并指向位于元素下面的元素。 更多细节关于pointer-events 张鑫旭MDN TODO 文本编辑虽已实现功能，但这块BUG较多，还未完善。 外部导入SVG这边也是用到了HTML5的Drop功能，显示则是用到了svg的images。拖拽实现比较简单： 12345678910111213dropHandle (e) &#123; let reader = new FileReader() let file = e.dataTransfer.files[0] reader.onload = (e) =&gt; &#123; this.userImages.push(e.target.result) &#125; reader.readAsDataURL(file)&#125;,dragoverHandle () &#123;&#125;,dragstart (imgSrc) &#123; event.dataTransfer.setData('URL', imgSrc)&#125; 这边需要注意的是@drop.stop.prevent=&quot;dropHandle&quot; @dragover.stop.prevent=&quot;dragoverHandle&quot;要阻止冒泡以及阻止浏览器默认行为。 还有一个要注意的是dataTransfer.getData()在dragover,dragenter,dragleave中无法获取数据的问题 根据W3C标准，drag data store有三种模式，Read/write mode, Read-only mode跟Protected mode。细节 Read/write mode读/写模式，在dragstart事件中使用，可以添加新数据到drag data store中。 Read-only mode只读模式，在drop事件中使用，可以读取被拖拽数据，不可添加新数据。 Protected mode保护模式，在所有其他的事件中使用，数据的列表可以被枚举，但是数据本身不可用且不能添加新数据。 深入 撤销与重做这一功能本质上是没有完成的，因为采用了一种偷懒的方式，vuex 生成 State 快照，生产环境不建议使用。 基本原理就是通过vuex提交更高（mutation）来触发回调。以此来记录state 快照 代码直通车 总结本项目属于入门级的vue+vuex,但是并没有讲如何使用vue或者vuex，因为这些在官方文档其实都已经讲的非常清楚了。该项目也只是简单使用了如vue的自定义指令，MiXin等常用方法。诸如vue Render函数组件，不在本文谈论范围，这里简单讲下使用体验，render组件比较适合高自定义的组件（变化逻辑比较复杂）。因为一些简单组件其实更适合用tempalte的形式，虽然使用Render可以提高一定的性能( 减少了从tempalte到render这一步 )，但是很多现有的如sync，是render组件所不具备的（ 需自己实现 ）。vuex的使用，则需要注意的是object引用地址的问题。也就是说，要避免数据间的潜在影响。（虽然vuex自身也有规避这个问题）可以了解一下immutable 。 本教程主要讲述一个基于vue如何实现一个简单的流程图，更多引发的思考是，什么项目更适合使用这种MVVM模式的框架，以及如何发挥VitrualDOM的价值。其实上面几个章节的点随便拿个出来都可以深入探讨出很多技术问题，以后有机会再陆续深入。]]></content>
  </entry>
  <entry>
    <title><![CDATA[英文翻译技巧]]></title>
    <url>%2F2017%2F10%2F15%2F%E8%8B%B1%E6%96%87%E7%BF%BB%E8%AF%91%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[我不是搞翻译的，大学英语也忘得差不多了，我只想阅读英文技术文档的时候无痛。既然有需求，就此记录成长点滴 英语语法 英语语法是针对英语语言进行研究后，英语语法系统地总结归纳出来的一系列语言规则。英语语法的精髓在于掌握语言的使用。 实词(在句子中独立担任成分) 名词 n. (noun) 表示人或事物的名称 代词pron. (pronoun) 代替名词、形容词或数词 数词num. (numeral) 表示数量或顺序 动词v. (verb) 表示动作或状态 形容词adj. (adjective) 表示名词(人或物)的特征 虚词(不能在句子中独立担任任何成分) 冠词art. (article) 用在名词前，说明名词所指的人、物 介词prep. (preposition) 用在名词、代词前，表示名词、代词等与其它词的关系 连词conj. (conjunction) 用来连接词与词、短语与短语、句与句 感叹词int. (interjection) 表示说话时的感情或口气 句类 陈述句 说明一个事实或陈述说话人的看法 肯定句、否定句 疑问句 提出问题 一般疑问句、选择疑问句、反意疑问句、特殊疑问句等 祈使句 表示请求、命令、劝告、建议等 感叹句 表示喜怒哀乐等强烈的情感 简单句 只有一套主、谓语的句子 并列句 由两个及以上并列而又互相独立的简单句构成 复合句 由一个主句和至少一个从句构成 主语从句、表语从句、宾语从句、定语从句、状语从句等 主谓宾定状补 主干枝叶分清楚 主干成分主谓宾 枝叶成分定状补 定语必居主宾前 谓前为状谓后补 翻译腔看到一个新名词，翻译腔。 “翻译腔”指翻译出来的译文有洋化现象或不符合汉语的习惯表达方式。表现为译文不自然、不流畅、生硬、费解、有歧义等特点。 而翻译的根本在于正确传递意思。 翻译时若不求甚解但求快速对等文字，得出的译文必然翻译腔浓重，生硬费解达不成目的，这种译文只能算“半成品”，甚至是“不合格品”。 翻译的五大雷区1.This album is one of my early pieces. 原译：这个册页是我的早期作品之一 改译：这个册页是我的早期作品。 评析：滥用冠词、数量词——根据语义，尽量转化，能省则省 2.He is a vegetarian. 原译：他是一个素食主义者。 改译：他是素食主义者。 改译2：他吃素。 评析：英语倾向用名词，汉语倾向用动词，处理 “一个+名词”的结构时，不妨尝试把名词转化为动词。 3.Rome is a city famous for its numerous fountains. 原译：罗马素以其喷泉众多而闻名于世。 改译：罗马喷泉众多，闻名于世。 评析：滥用代词“其”——必须删去。英文中有时态，汉语中无时态，简明起见，无需采用“素以”来表达一般现在时，建议删去。英文是形合语言，倾向于明示逻辑，汉语是意合语言，倾向于暗含逻辑，所以逻辑连词“而”建议删去。 4.We closely observe the changes of patient’s conditions. 原译：我们对患者病情的变化进行密切观察。 改译：我们密切观察患者病情的变化。 评析：滥用弱动词“进行”——建议在修饰名词不太长的情况下删去。 5.Solutions to the problem are as varied as theories regarding causes. 原译：对于该问题的起因众说纷纭，而针对该问题的解决方案同样五花八门。 改译：该问题的起因众说纷纭，解决方案同样五花八门。 评析：滥用介词“对于、针对”——酌情删去。 1、滥用冠词/数量词（一个、之一、们） 2、滥用代词（它、他/她、其、这、那） 3、滥用介词（对于、就……问题、关于、有关） 4、滥用弱动词（进行、作出、实施、开展） 英语和汉语有什么不同？ 引自 https://www.zhihu.com/question/21163865 亲爱的，当你的英语能力不足的时候，英语表达会本能的受到母语习惯的影响，这是不可避免的。没什么好办法，就是多接触authentic English，一步步来。但是，多多了解汉语和英语思维习惯上的不同，对你加快转变到所谓的“英语思维”是有帮助的，这也是这篇帖子的意义所在。理解汉语和英语在句法结构，构思调理，铺陈方式上的差异，比如英语重视开门见山，务求重点清楚，调理分明；汉语注重迂回，强调起承转合。汉语强调“意境”，而英语重视“句子结构”。看例子：中文常说“一群蜜蜂”，因此我看到过有人写“a group of bees”，其实这种说法是错误的，正确的用法是“a swarm of bees”。可以看出，汉语和英语有时候并不能想当然地做对等翻译。其实表达“群”这个意思，英语中还有：- “herd”用来形容大型动物，比如牛，羊，大象等等，比如：a herd of pigs。- “flock” 用来形容一群类似特性的动物或者人，“一群鸟”可以是“a flock of birds”。- “swarm”常常用来形容一群昆虫，如：a swarm of insects。英语和汉语有什么不同？从语言类型学上来讲，英语是主语优先的语言（subject-prominent），非常强调句子结构，表现在：主语不可或缺，因此即使主语没有语义作用，也必须存在，哪怕是it，there等做的“假位”主语。谓语在人称和数量上要和主语保持一致。而汉语是话题优先语言（topic-prominent），更加强调情景，通过建立情景传递信息，句子结构松散，有时候甚至没有主语。比如：中文：他肚子大，腿又短，鼻子很大，真难看。英文：He has a big belly. His legs are short. His nose is big. He looks ugly.通过上句子可以看出两种语言呈现方式的不同。中文先确立起来“话题”，建立情景后，之后的句子可以直接讲腿和鼻子，以及最后的“真难看”。通过建立的情景很自然了解到所有的描写的都是指向“他”的。而英语更加强调句子的结构性，每个句子都必须有独立的主语，这些主语加了所有格his才能和He联系起来。1， 两个语言这些不同的特性有时就会导致连贯性的问题。中文：我的家乡是西安。它有古老的城墙，是围城而建的。虽然它不是一个大城市，但有着悠久的历史和非比寻常的美景。中式英语：My hometown is Xian City. It has ancient walls. The walls are built all around the city. My hometown is not a big city, but it has a long history and its unusual beautiful scenery.汉语一开始就建立了情景，之后的句子都是围绕话题“西安”展开的，读起来并无不妥。但是，如果字对字的翻译到英文，虽然语法上并没有错误，但却是典型的中式英语。虽然保证了英语“强调句子结构”的要求，但是句子的主语由My hometown -&gt; It -&gt; The walls -&gt; My hometown -&gt; it，不但有重复，而且角色转换频繁，读起来有一种”跳跃“感。这是在英语写作中要避免的情况，改写如下：英语：My hometown, Xian, is a city with ancient walls all around it. Although, not big, it has a long history and unusual scenic beauty.两句相比，改写后的句子更加精炼，而且两个句的主语My hometown和it高度相关，衔接流畅。所以，英语要尽量保持句子主语之间的连贯性，尽量使主语围绕在一个话题上面。可是有时候，如果句子之间话题不同，话题和话题又如何转换？A man named Spencer Silver was working in the 3M research laboratories in 1970 trying to find a strong adhesive. He developed a new adhesive, butit was even weaker than those 3M manufactured. It stuck to objects, but could easily be lifted off.It should have been super-strong, but it turned out to be super-weak instead.本来主语是Silver这个人，后来跳跃到it，也就是“新的粘合剂”上面了，但是并不让人觉得突兀。开始在说Silver发明了粘合剂，但是不怎么粘。其实新的话题“a new adhesive”就已经被悄悄引出。那么原本围绕Silver的句子从第三句就变成以a new adhesive为主语的句子了。也就是说，如果必须要转换话题，最好由前一句中的“后叙成分”新旧话题转换中，想办法融入接下来要谈的“新话题”，完成有“新话题”向“旧话题”的流畅转换。再看一个例子：中文：我喜欢运动。我最喜欢的运动之一是羽毛球。我们办公室附近有一个健身房。最近，我加入了一个羽毛球队。这个球队现在大概有20人。这个球队的队长会定周日两个小时的羽毛球场地。每个人只需要每季度交200块钱。我们可以打男双，女双或者混双。由于队长会提供足够的球，我们只要准备自己的球拍就可以了。看出来了么，汉语句子主语经常换来换去，第一句是第一人称“我”，但是马上变成了“我们办公室”，往下类似。这种思维影响下字对字翻译写出来的英语就是典型的中式英语，读起来跳跃感十足：中式英语：I love sports. One of my favourite sports is badminton. Near our office, there is a gym. Recently, I joined a badminton group. There are about 20 people in the group for now. The leader of this group books a field for two hours every Sunday. Each person just needs to pay 200 yuan per season. We can play men’s doubles, women’s doubles or mixed-doubles.第二句是one of my favourite sports，然后马上是our office。虽然是对中文的直译，但是这里的our不能和前文产生任何联系，所以应该改成my。另外，句子之间主题跳跃太大，从第二句gym到后面的badminton group，中间毫无联系。在写作中，最后在它们之间加句子使得语义连接：I often played badminton with my colleagues there.2, 汉语思维和英语思维的不同。在表达上面，汉语更加注重迂回渐进，起承转合，常常先说理由再引出结论，而英文更加开门见山。如下图，汉语是一种circular thinking，相反，英文是一种线性思维。英语中常常首先切入主题（key point），然后才写细节（supporting details），最后写总结。&lt;img src=”https://pic4.zhimg.com/50/6dbd9702fc2413ced6c0dceebb57ef23_hd.png“ data-rawwidth=”790” data-rawheight=”346” class=”origin_image zh-lightbox-thumb” width=”790” data-original=”https://pic4.zhimg.com/6dbd9702fc2413ced6c0dceebb57ef23_r.png&quot;&amp;gt;— 图片来自[1]例子：汉语：我们的国家还在发展阶段，所以我们要努力工作发展国家，同时保持节俭。中式英语：Our country is still in the stage of development, so we need to work hard to make our country more developed, and we should be thrifty at the same time.修改后：We should work hard to make our country more developed, and we should be thrifty at the same time because our country is still in the stage of development.汉语先解释理由，再说出观点。英语更多的先表明观点再说出理由。这就是两种思维上的不同。准备过雅思托福考试的朋友，想一想你的写作参考书上是不是都让你先写结论再用细节和例子支持你的观点？3，被动语态。汉语思维大量用人称做主语（animated subject），而英语多用非人称做主语（non-animated subject），这是因为英语思维更强调客观性。在英语中，几乎所有的事物都是可以当主语的，但是汉语不行。比如，Too much water killed the flower如果翻译成“太多的水杀死的这朵花”就不符合汉语习惯，应该是说“水浇的太多，花死了。”第一种翻译之所以别扭是因为汉语强调“杀死”这类动词的执行者必须是有意识的主语（animated）；英语的kill并没有这种限制。例子：中文：我收到一份急电，去了上海。中式英文：I’ve received an urgent telegraph, and so I went to Shanghai.这是按照汉语思维字对字翻译的，但是更符合英语思维的翻译是“A urgent telegraph forced me to rush to Shanghai.” 但是这句话如果直译为汉语又变成了“一封紧急电报迫使我去了上海。”，虽然可以理解，但在汉语看来却有些不太地道。中文：我突然想到个好主意。中式英语：I suddenly got a good idea.地道英语：A good idea suddenly occurred to me.仔细品味一下不同，显然用a good idea更加符合原来句子的意味。再近一步，英语中的非人称主语往往可以非常生动，掌握这一点可以使我们写出非常地道的英文句子。中式英语：She was so jealous that she became desperate.地道英语：Jealousy drove her to despair.中式英语：She was very miserable and her heart broke.地道英语：Misery tore her into pieces.由于中文用人称主语，所以人往往要早于动作出现。而在英语中，非人称主语（misery，jealousy）放在句首，更加有感染力。学英语，欢迎加公众号http://weixin.qq.com/r/ETt0bGzEkzHsrSgP924D (二维码自动识别)[1] Causes of and Remedies for Chinglish in Chinese College Student’s Writings. Ping Wang, 2012 参考一小时学会翻译技巧 英语语法]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码相关]]></title>
    <url>%2F2017%2F10%2F14%2F%E7%BC%96%E7%A0%81%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[最近在重温JavaScript高程String的时候遇到了编码，虽然编程这么久，但从来没有了解过，先来扫盲一下 编码是信息从一种形式或格式转换为另一种形式的过程也称为计算机编程语言的代码简称编码。 定义在计算机硬件中，编码（coding）是指用代码来表示各组数据资料，使其成为可利用计算机进行处理和分析的信息。 数字系统中常用的编码有两类，一类是二进制编码，另一类是十进制编码。 常见编码编码内容涉及太多，下面介绍两种常见的编码ASCII、Unicode Unicode Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准,包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布。 Unicode 编码包含了不同写法的字，如“ɑ/a”、“户/户/戸”。然而在汉字方面引起了一字多形的认定争议。 在文字处理方面，统一码为每一个字符而非字形定义唯一的代码（即一个整数）。换句话说，统一码以一种抽象的方式（即数字）来处理字符，并将视觉上的演绎工作（例如字体大小、外观形状、字体形态、文体等）留给其他软件来处理，例如网页浏览器或是文字处理器。 Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。目前的Unicode字符分为17组编排，0x0000 至 0xFFFF，每组称为平面（Plane），而每平面拥有65536个码位，共1114112个。然而目前只用了少数平面。UTF-8、UTF-16、UTF-32都是将数字转换到程序数据的编码方案。 utf8是对unicode字符集进行编码的一种编码方式。 深入理解入口 ASCIIASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统，并等同于国际标准ISO/IEC 646。 请注意，ASCII是American Standard Code for Information Interchange缩写，而不是ASCⅡ(罗马数字2)，有很多人在这个地方产生误解。 ASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。标准ASCII 码也叫基础ASCII码，使用7 位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号， 以及在美式英语中使用的特殊控制字符。 深度扫盲 ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。 推荐阅读：字符编码的故事 TODO：光了解常识对进阶似乎并没用，以后在工作中若有涉及再深入研究 ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统，并等同于国际标准ISO/IEC 646。]]></content>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CDN详解]]></title>
    <url>%2F2017%2F10%2F13%2FCDN%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[经常遇到前端面试涉及CND相关，特留此博文待时机到时好好表现一下（装B一次）。博文会不间断更新，将其作为CDN知识存储点。 简介Content Delivery Network或Content Ddistribute Network，即内容分发网络 简单地说，CDN是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请求的重定向和内容管理4个要件，而内容管理和全局的网络流量管理(Traffic Management)是CDN的核心所在。 通过用户就近性和服务器负载的判断，CDN确保内容以一种极为高效的方式为用户的请求提供服务。 为什么要使用CDN解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度和成功率。 控制时延无疑是现代信息科技的重要指标，CDN的意图就是尽可能的减少资源在转发、传输、链路抖动等情况下顺利保障信息的连贯性。 链路: 指无源的点到点的物理连接。有线通信时，链路指两个节点之间的物理线路，如电缆或光纤。无线电通信时，链路指基站和终端之间传播电磁波的路径空间。水声通信时链路指换能器和水听器之间的传播声波的路径空间。 为了实现跨运营商、跨地域的全网覆盖 互联不互通、区域ISP地域局限、出口带宽受限制等种种因素都造成了网站的区域性无法访问。CDN加速可以覆盖全球的线路，通过和运营商合作，部署IDC资源，在全国骨干节点商，合理部署CDN边缘分发存储节点，充分利用带宽资源，平衡源站流量。 为了保障你的网站安全 CDN的负载均衡和分布式存储技术，可以加强网站的可靠性。 TODO 什么是负载均衡和分布式存储技术 为了异地备援 当某个服务器发生意外故障时，系统将会调用其他临近的健康服务器节点进行服务，进而提供接近100%的可靠性，这就让你的网站可以做到永不宕机。 TODO 原理是啥？ 为了节约成本投入 使用CDN加速可以实现网站的全国铺设，你根本不用考虑购买服务器与后续的托管运维，服务器之间镜像同步，也不用为了管理维护技术人员而烦恼，节省了人力、精力和财力。 为了让你更专注业务本身 CDN加速厂商一般都会提供一站式服务，业务不仅限于CDN，还有配套的云存储、大数据服务、视频云服务等，而且一般会提供7x24运维监控支持，保证网络随时畅通，你可以放心使用。并且将更多的精力投入到发展自身的核心业务之上。 控制时延 0.1 s： 用户几乎感觉不到系统是否不连贯性。1.0 s： 用户明显注意到时延的发生，但是在该时间内思维依然是连贯的。10 s： 超过该时间的时延会使用户失去等待意愿。 基本思路及原理尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。 最简单的CDN网络由一个DNS服务器和几台缓存服务器组成： 当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。 CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。 用户向CDN的全局负载均衡设备发起内容URL访问请求。 CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。 区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。 全局负载均衡设备把服务器的IP地址返回给用户。 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。 实际应用国内访问量较高的网站、直播、视频平台，均使用CDN网络加速技术，虽然网站的访问巨大，但无论在什么地方访问都会感觉速度很快。而一般的网站如果服务器在网通，电信用户访问很慢，如果服务器在电信，网通用户访问又很慢。 通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的cache服务器内，通过DNS负载均衡的技术，判断用户来源就近访问cache服务器取得所需的内容，解决Internet网络拥塞状况，提高用户访问网站的响应速度，如同提供了多个分布在各地的加速器，以达到快速、可冗余的为多个网站加速的目的。 CDN服务最初用于确保快速可靠地分发静态内容，这些内容可以缓存，最适合在网速庞大的网络中存储和分发，该网络在几十多个国家的十几个网络中的覆盖CDN网络服务器。由于动态内容必须通过互联网来传输，因此要提供快速的网络体验。如今的CDN可谓是大文件、小文件、点播、直播、动静皆宜！ 主要特点1、本地Cache加速，提高了企业站点（尤其含有大量图片和静态页面站点）的访问速度，并大大提高以上性质站点的稳定性 2、镜像服务消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。 3、远程加速 远程访问用户根据DNS负载均衡技术 智能自动选择Cache服务器，选择最快的Cache服务器，加快远程访问的速度 4、带宽优化 自动生成服务器的远程Mirror（镜像）cache服务器，远程用户访问时从cache服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点WEB服务器负载等功能。 5、集群抗攻击 广泛分布的CDN节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种D.D.o.S攻击对网站的影响，同时保证较好的服务质量 。 参考文档视界云]]></content>
      <tags>
        <tag>CDN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语句后是否需要分号]]></title>
    <url>%2F2017%2F10%2F12%2F%E8%AF%AD%E5%8F%A5%E5%90%8E%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E5%88%86%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[该思考来自于阅读JavaScript高级程序建议语句后都加分号及Eslint中不建议带分号。 虽然语句结尾的分号不是必需的，但我们建议任何时候都不要省略它。因为加上这个分号可以避免 很多错误(例如不完整的输入)，开发人员也可以放心地通过删除多余的空格来压缩 ECMAScript 代码(代 码行结尾处没有分号会导致压缩错误)。另外，加上分号也会在某些情况下增进代码的性能，因为这样 解析器就不必再花时间推测应该在哪里插入分号了。 – 引自JavaScript高程 3.1.5 语句 高程里说的增加性能实在难以服众，至于导致语法错误可以继续往下看。 Standard建议无分号 相关文章 另外，尤大在知乎的说法 没有应该不应该，只有你自己喜欢不喜欢。JavaScript 语法长得 C-like 不代表它本质上和 C 是一类语言，所有直觉性的 “当然应该加分号” 都是保守的、未经深入思考的草率结论。后来新设计的语言里可选分号的多得去了，光是 “可以加分号但是大家都不加” 的语言就有：Go, Scala, Ruby, Python, Swift, Groovy… 至于说 “很难总结什么时候加不加”，其实真的很简单。真正会导致上下行解析出问题的 token 有 5 个：括号，方括号，正则开头的斜杠，加号，减号。我还从没见过实际代码中用正则、加号、减号作为行首的情况，所以总结下来就是一句话：一行开头是括号或者方括号的时候加上分号就可以了，其他时候全部不需要。其实即使是这两种情况，在实际代码中也颇为少见。 尤大贡献的 github commit hook 可是由于无分号导致的，该代码运行错误 123const a = 2[ 3, 4 ].forEach(n =&gt; console.log(n)) 什么是ASI按照 ECMAScript 标准，一些 特定语句（statement) 必须以分号结尾。分号代表这段语句的终止。但是有时候为了方便，这些分号是有可以省略的。这种情况下解释器会自己判断语句该在哪里终止。这种行为被叫做 “自动插入分号”，简称 ASI (Automatic Semicolon Insertion) 。实际上分号并没有真的被插入，这只是个便于解释的形象说法。 这些特定的语句有： 空语句 let const import export 变量赋值 表达式 debugger continue break return throw ASI 规则ECMAScript 标准定义的 ASI 包括 三条规则 和 两条例外。 三条规则是描述何时该自动插入分号： 解析器从左往右解析代码（读入 token），当碰到一个不能构成合法语句的 token 时，它会在以下几种情况中在该 token 之前插入分号，此时这个不合群的 token 被称为 offending token ： 如果这个 token 跟上一个 token 之间有至少一个换行。 如果这个 token 是 }。 如果 前一个 token 是 )，它会试图把前面的 token 理解成 do…while 语句并插入分号。 当解析到文件末尾发现语法还是有问题，就会在文件末尾插入分号。 当解析时碰到 restricted production 的语法（比如 return），并且在 restricted production 规定的 [no LineTerminator here] 的地方发现换行，那么换行的地方就会被插入分号。 总结至于高程说的可以避免错误，我觉得这些错误本身是应该改掉的编码习惯。而性能，对于现在的引擎来说应该可以忽略不计。 Eslint之所以提倡无分号，可能也是从另一个出发点来改掉编码者的不良习惯。 参考 http://cnodejs.org/topic/56dbbd25820d3c9b3d63e369]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[algolia不完全指南]]></title>
    <url>%2F2017%2F10%2F12%2Falgolia%2F</url>
    <content type="text"><![CDATA[hexo可以集成站内搜索服务，本文将介绍一种基于algolia中docsearch的使用方法。 本文主要介绍如何自定义algolia的爬虫内容 algolia使用 algolia官网注册账号（可直接使用的github的账号） 新建index API Keys 界面里包含 Application ID Search-Only API Key 刚接触algolia的同学可以参考这篇 docsearch使用123456789&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" /&gt;&lt;script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;docsearch(&#123; apiKey: '&lt;API_KEY&gt;', indexName: '&lt;INDEX_NAME&gt;', inputSelector: '&lt;YOUR_INPUT_DOM_SELECTOR&gt;'&#125;);&lt;/script&gt; docsearch-scraper使用ubuntu环境下 1234apt-get install pythongit clone git@github.com:algolia/docsearch-scraper.gitcd docsearch-scraperpip install --user -r requirements.txt 执行以下命令 1./docsearch 第一次执行会提示输入APPLICATION_ID及API_KEY，此处API_KEY对应algolia API Keys界面里的 admin Key 在docsearch-scraper目录下新建名为test.json的文件，写入相关配置，后执行 1./docsearch run test.json docsearch-configs配置文件如下 12345678910111213141516171819202122&#123; "index_name": "stripe", // 对应algolia里的indexName "start_urls": [ "https://stripe.com/docs" // 待抓取开始网址 可为本地 http://localhost:4000 (hexo博客本地服务) ], "stop_urls": [ "https://stripe.com/docs/api" ], "selectors": &#123; "lvl0": "#content header h1", "lvl1": "#content article h1", "lvl2": "#content section h3", "lvl3": "#content section h4", "lvl4": "#content section h5", "lvl5": "#content section h6", "text": "#content header p,#content section p,#content section ol" &#125;, "selectors_exclude": [ ".method-list", "aside.note" ]&#125; 至此一个hexo搜索功能搭建完毕，感谢algolia和hexo。同时可参考vue 官方文档源码，可快速搭建自己的参考手册或教程类网站。 相关Github链接 algolia docsearch docsearch-scraper docsearch-configs]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>algolia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo入门指南]]></title>
    <url>%2F2017%2F10%2F10%2Fhexo%2F</url>
    <content type="text"><![CDATA[hexo可用于快速搭建githubPage，是一个JS语言编写的静态网站生成器，主要作用是解析Markdown语法，并配合模板引擎，快速生成静态网站。 快速使用 A fast, simple &amp; powerful blog framework, powered by Node.js. hexo官网 12345678910111213npm install hexo-cli -ghexo init blogcd blognpm installhexo serverhexo new "Hello Hexo" # 新建文章hexo generate 实时监听文件修改推荐使用hexo-browsersync 1npm install hexo-browsersync --save 注意： 由于使用了hexo-browsersync在本地当文章字数过多时会出现乱码的情况，线上由于没该插件影响不会乱码。 配置 BrowserSync options are supported inside _config.yml file, e.g.: 1234browsersync: logLevel: "warn" ghostMode: scroll: true You can check BrowserSync options for more info. browsersync 一键部署基于Git，首先安装 hexo-deployer-git 1npm install hexo-deployer-git --save 其次在 _config.yml 中修改参数 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 1hexo g -d 插件Hexo 有强大的插件系统，使您能轻松扩展功能而不用修改核心模块的源码。在 Hexo 中有两种形式的插件： 脚本（Scripts）如果您的代码很简单，建议您编写脚本，您只需要把 JavaScript 文件放到 scripts 文件夹，在启动时就会自动载入。 插件（Packages）如果您的代码较复杂，或是您想要发布到 NPM 上，建议您编写插件。首先，在 node_modules 文件夹中建立文件夹，文件夹名称开头必须为 hexo-，如此一来 Hexo 才会在启动时载入否则 Hexo 将会忽略它。 文件夹内至少要包含 2 个文件：一个是主程序，另一个是 package.json，描述插件的用途和所依赖的插件。 123.├── index.js└── package.json package.json 中至少要包含 name, version, main 属性，例如： 12345&#123; "name": "hexo-my-plugin", "version": "0.0.1", "main": "index"&#125; 标签插件 标签插件帮助开发者在文章中快速插入内容。 12345678910111213141516171819/* global hexo */'use strict';hexo.extend.tag.register('note', function(args, content) &#123; var className = args.shift(); var header = ''; var result = ''; if (args.length) &#123; header += '&lt;strong class="note-title"&gt;' + args.join(' ') + '&lt;/strong&gt;'; &#125; result += '&lt;blockquote class="note ' + className + '"&gt;' + header; result += hexo.render.renderSync(&#123;text: content, engine: 'markdown'&#125;); result += '&lt;/blockquote&gt;'; return result;&#125;, true); next主题 NexT 拥有丰富而简单的配置，结合第三方服务，打造属于您自己的博客 next官网 安装项目目录下执行git clone https://github.com/iissnan/hexo-theme-next themes/next 基础配置在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 在站点文件下 12theme: next # 主题选择language: zh-Hans # 语言选择 在主题配置文件下 1234567891011121314scheme: Pisces # 主题样式menu: # 菜单设置 home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.htmlsidebar: # 侧栏位置 position: left #头像设置avatar: http://example.com/avatar.pnglocal_search: enable: true 集成服务搜索服务 Local Search 1npm install hexo-generator-searchdb --save 内建标签文本居中的引用1&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125; 突破容器宽度限制的图片 1&#123;% fi /image-url, alt, title %&#125; Bootstrap Callout 1&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125; 其中，class_name 可以是以下列表中的一个值： default primary success info warning danger]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
