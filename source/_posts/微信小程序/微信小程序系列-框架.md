---
title: 微信小程序
---

开发者工具 [win64](https://servicewechat.com/wxa-dev-logic/download_redirect?type=x64&from=mpwiki&t=20161122) [win32](https://servicewechat.com/wxa-dev-logic/download_redirect?type=ia32&from=mpwiki&t=20161122) [mc](https://servicewechat.com/wxa-dev-logic/download_redirect?type=darwin&from=mpwiki&t=20161122)

扫码登录,输入AppId,登录 <https://mp.weixin.qq.com> 查看微信小程序的 AppID

# 文件结构

小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。

一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下：

文件     | 必填 | 作用
---------|------|---------------
app.js   | 是   | 小程序逻辑
app.json | 是   | 小程序公共设置
app.wxss | 否   | 小程序公共样式

一个小程序页面由四个文件组成，分别是：

文件类型 | 必填 | 作用
---------|------|-----------
js       | 是   | 页面逻辑
wxml     | 是   | 页面结构
wxss     | 否   | 页面样式表
json     | 否   | 页面配置

**注意：为了方便开发者减少配置项，我们规定描述页面的这四个文件必须具有相同的路径与文件名。**

# 配置

`app.json`文件对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等

以下是一个包含了所有配置选项的简单配置app.json ：

```js
{
  "pages": [
    "pages/index/index",
    "pages/logs/index"
  ],
  "window": {
    "navigationBarTitleText": "Demo"
  },
  "tabBar": {
    "list": [{
      "pagePath": "pages/index/index",
      "text": "首页"
    }, {
      "pagePath": "pages/logs/logs",
      "text": "日志"
    }]
  },
  "networkTimeout": {
    "request": 10000,
    "downloadFile": 10000
  },
  "debug": true
}
```

- pages 设置页面路径 接受一个数组，每一项都是字符串，来指定小程序由哪些页面组成。每一项代表对应页面的【路径+文件名】信息，数组的第一项代表小程序的初始页面。小程序中新增/减少页面，都需要对 pages 数组进行修改。

文件名不需要写文件后缀，因为框架会自动去寻找路径.json,.js,.wxml,.wxss的四个文件进行整合。

- window 设置默认页面的窗口表现 用于设置小程序的状态栏、导航条、标题、窗口背景色。

  - navigationBarBackgroundColor 导航栏背景颜色 默认`#000`
  - navigationBarTextStyle 导航栏标题颜色 默认`white`
  - navigationBarTitleText 导航栏标题文字内容
  - backgroundColor 窗口的背景色 默认`#fff`
  - backgroundTextStyle 下拉背景字体、loading 图的样式，仅支持 dark/light
  - enablePullDownRefresh 默认 `false` 是否开启下拉刷新

``` js
{
  "window":{
    "navigationBarBackgroundColor": "#ffffff",
    "navigationBarTextStyle": "black",
    "navigationBarTitleText": "微信接口功能演示",
    "backgroundColor": "#eeeeee",
    "backgroundTextStyle": "light"
  }
}
```

- tabBar
tabBar 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。
 - color tab 上的文字默认颜色
 - selectedColor tab 上的文字选中时的颜色
 - backgroundColor tab 的背景色
 - borderStyle tabbar上边框的颜色， 仅支持 black/white
 - list tab 的列表，详见 list 属性说明，最少2个、最多5个 tab
 - position 可选值 bottom、top

其中 list 接受一个数组，数组中的每个项都是一个对象，其属性值如下：
 - pagePath 页面路径，必须在 pages 中先定义
 - text tab 上按钮文字
 - iconPath 图片路径，icon 大小限制为40kb
 - selectedIconPath 选中时的图片路径，icon 大小限制为40kb

- networkTimeout
可以设置各种网络请求的超时时间。
 - request `wx.request的超时时间，单位毫秒`
 - connectSocket `wx.connectSocket的超时时间，单位毫秒`
 - uploadFile `wx.uploadFile的超时时间，单位毫秒`
 - downloadFile `wx.downloadFile的超时时间，单位毫秒`

- debug
可以在开发者工具中开启 debug 模式，在开发者工具的控制台面板，调试信息以 info 的形式给出，其信息有Page的注册，页面路由，数据更新，事件触发 。 可以帮助开发者快速定位一些常见的问题。

- `page.json`
每一个小程序页面也可以使用`.json文件来对本页面的窗口表现进行配置`。 页面的配置比`app.json全局配置简单得多`，只是设置 `app.json` 中的 `window `配置项的内容，页面中配置项会覆盖 `app.json` 的 `window` 中相同的配置项。

页面的`.json只能设置 window` 相关的配置项，以决定本页面的窗口表现，所以无需写` window`这个键，如：
``` js
{
  "navigationBarBackgroundColor": "#ffffff",
  "navigationBarTextStyle": "black",
  "navigationBarTitleText": "微信接口功能演示",
  "backgroundColor": "#eeeeee",
  "backgroundTextStyle": "light"
}
```

# 逻辑层

首先来设置使用 Git 时的姓名和邮箱地址。名字请用英文输入。

- 增加 App 和 Page 方法，进行程序和页面的注册。
- 增加 getApp 和 getCurrentPages 方法，分别用来获取 App 实例和当前页面栈。
- 提供丰富的 API，如微信用户数据，扫一扫，支付等微信特有能力。
- 每个页面有独立的作用域，并提供模块化能力。
- 由于框架并非运行在浏览器中，所以 JavaScript 在 web 中一些能力都无法使用，如 document，window 等。
- 开发者写的所有代码最终将会打包成一份 JavaScript，并在小程序启动的时候运行，直到小程序销毁。类似 ServiceWorker，所以逻辑层也称之为 App Service。

## App

### App()

函数用来注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。

**object参数说明：**

- onLaunch	Function	生命周期函数--监听小程序初始化	当小程序初始化完成时，会触发 onLaunch（全局只触发一次）
- onShow	Function	生命周期函数--监听小程序显示	当小程序启动，或从后台进入前台显示，会触发 onShow
- onHide	Function	生命周期函数--监听小程序隐藏	当小程序从前台进入后台，会触发 onHide
- 其他	Any	开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问

前台、后台定义： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。

只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。

示例代码：
``` js
App({
  onLaunch: function() {
    // Do something initial when launch.
  },
  onShow: function() {
      // Do something when show.
  },
  onHide: function() {
      // Do something when hide.
  },
  globalData: 'I am global data'
})
```

### getApp()

全局的 getApp() 函数，可以获取到小程序实例。

```js
// other.js
var appInstance = getApp()
console.log(appInstance.globalData) // I am global data
```

App() 必须在 app.js 中注册，且不能注册多个。

不要在定义于 App() 内的函数中调用 getApp() ，使用 this 就可以拿到 app 实例。

不要在 onLaunch 的时候调用 getCurrentPage()，此时 page 还没有生成。

通过 getApp() 获取实例之后，不要私自调用生命周期函数。

## Page

### Page()

函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。

**object 参数说明：**

- data	Object	页面的初始数据
- onLoad	Function	生命周期函数--监听页面加载
- onReady	Function	生命周期函数--监听页面初次渲染完成
- onShow	Function	生命周期函数--监听页面显示
- onHide	Function	生命周期函数--监听页面隐藏
- onUnload	Function	生命周期函数--监听页面卸载
- onPullDownRefresh	Function	页面相关事件处理函数--监听用户下拉动作
- onReachBottom	Function	页面上拉触底事件的处理函数
- 其他	Any	开发者可以添加任意的函数或数据到 object 参数中，在页面的函数中用 this 可以访问

**示例代码：**
```js
//index.js
Page({
  data: {
    text: "This is page data."
  },
  onLoad: function(options) {
    // Do some initialize when page load.
  },
  onReady: function() {
    // Do something when page ready.
  },
  onShow: function() {
    // Do something when page show.
  },
  onHide: function() {
    // Do something when page hide.
  },
  onUnload: function() {
    // Do something when page close.
  },
  onPullDownRefresh: function() {
    // Do something when pull down.
  },
  onReachBottom: function() {
    // Do something when page reach bottom.
  },
  // Event handler.
  viewTap: function() {
    this.setData({
      text: 'Set some data for updating view.'
    })
  },
  customData: {
    hi: 'MINA'
  }
})
```

### 初始化数据

初始化数据将作为页面的第一次渲染。data 将会以 JSON 的形式由逻辑层传至渲染层，所以其数据必须是可以转成 JSON 的格式：字符串，数字，布尔值，对象，数组。

渲染层可以通过 WXML 对数据进行绑定。

**示例代码：**

```xml
<view>{{text}}</view>
<view>{{array[0].msg}}</view>
```

```js
Page({
  data: {
    text: 'init data',
    array: [{msg: '1'}, {msg: '2'}]
  }
})
```

### 生命周期函数
- onLoad: 页面加载
  - 一个页面只会调用一次。
  - 接收页面参数可以获取wx.navigateTo和wx.redirectTo及`<navigator/>`中的 query。
- onShow: 页面显示
  - 每次打开页面都会调用一次。
- onReady: 页面初次渲染完成
  - 一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。
  - 对界面的设置如wx.setNavigationBarTitle请在onReady之后设置。详见生命周期
- onHide: 页面隐藏
  - 当navigateTo或底部tab切换时调用。
- onUnload: 页面卸载
  - 当redirectTo或navigateBack的时候调用。

### 页面相关事件处理函数
- onPullDownRefresh: 下拉刷新
  - 监听用户下拉刷新事件。
  - 需要在config的window选项中开启enablePullDownRefresh。
  - 当处理完数据刷新后，wx.stopPullDownRefresh可以停止当前页面的下拉刷新。

### 事件处理函数

除了初始化数据和生命周期函数，Page 中还可以定义一些特殊的函数：事件处理函数。在渲染层可以在组件中加入事件绑定，当达到触发事件时，就会执行 Page 中定义的事件处理函数。

**示例代码：**

```xml
<view bindtap="viewTap"> click me </view>
```

```js
Page({
  viewTap: function() {
    console.log('view tap')
  }
})
```

### `Page.prototype.setData()`

`setData` 函数用于将数据从逻辑层发送到视图层，同时改变对应的 `this.data` 的值。

**注意：**
1. 直接修改 this.data 无效，无法改变页面的状态，还会造成数据不一致。
2. 单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。

### `setData() 参数格式`

接受一个对象，以 key，value 的形式表示将 this.data 中的 key 对应的值改变成 value。

其中 key 可以非常灵活，以数据路径的形式给出，如 array[2].message，a.b.c.d，并且不需要在 this.data 中预先定义。

**示例代码：**
```xml
<!--index.wxml-->
<view>{{text}}</view>
<button bindtap="changeText"> Change normal data </button>
<view>{{array[0].text}}</view>
<button bindtap="changeItemInArray"> Change Array data </button>
<view>{{object.text}}</view>
<button bindtap="changeItemInObject"> Change Object data </button>
<view>{{newField.text}}</view>
<button bindtap="addNewField"> Add new data </button>
```

```js
//index.js
Page({
  data: {
    text: 'init data',
    array: [{text: 'init data'}],
    object: {
      text: 'init data'
    }
  },
  changeText: function() {
    // this.data.text = 'changed data'  // bad, it can not work
    this.setData({
      text: 'changed data'
    })
  },
  changeItemInArray: function() {
    // you can use this way to modify a danamic data path
    this.setData({
      'array[0].text':'changed data'
    })
  },
  changeItemInObject: function(){
    this.setData({
      'object.text': 'changed data'
    });
  },
  addNewField: function() {
    this.setData({
      'newField.text': 'new data'
    })
  }
})
```

### `getCurrentPages()`

`getCurrentPages()` 函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。

**注意：不要尝试修改页面栈，会导致路由以及页面状态错误。**

### 页面栈

框架以栈的形式维护了当前的所有页面。 当发生路由切换的时候，页面栈的表现如下：


路由方式   | 页面栈表现
-----------|-----------------------------------------
初始化     | 新页面入栈
打开新页面 | 新页面入栈
页面重定向 | 当前页面出栈，新页面入栈
页面返回   | 页面不断出栈，直到目标返回页，新页面入栈
Tab 切换   | 当前页面出栈，新页面入栈

https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html

### 页面的路由

在小程序中所有页面的路由全部由框架进行管理，对于路由的触发方式以及页面生命周期函数如下：
路由方式  | 触发时机  |路由后页面  |  路由前页面
--|---|---|--
  初始化| 小程序打开的第一个页面  |  onLoad，onShow |
  打开新页面|  调用 `API wx.navigateTo` 或使用组件` <navigator />` | onLoad，onShow  |onHide
页面重定向  |  调用 `API wx.redirectTo` 或使用组件 `<navigator />` |  onLoad，onShow |onUnload
页面返回  |  调用 `API wx.navigateBack`或用户按左上角返回按钮 | onShow  |onUnload（多层页面返回每个页面都会按顺序触发onUnload）
Tab 切换  |  多 Tab 模式下用户切换 Tab |   第一次打开 onLoad，onshow；否则 onShow|onHide

### `Bug & Tip`
1. bug: iOS/Android 6.3.30, 首次进入页面，如果页面不满一屏时会触发 onReachBottom ，应为只有用户主动上拉才触发；
2. bug: iOS/Android 6.3.30, 手指上拉，会触发多次 onReachBottom ，应为一次上拉，只触发一次；

## 文件作用域

在 JavaScript 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。

通过全局函数 `getApp()` 可以获取全局的应用实例，如果需要全局的数据可以在 `App()` 中设置，如：
```js
// app.js
App({
  globalData: 1
})
```

```js
// a.js
// The localValue can only be used in file a.js.
var localValue = 'a'
// Get the app instance.
var app = getApp()
// Get the global data and change it.
app.globalData++
```

```js
// b.js
// You can redefine localValue in file b.js, without interference with the localValue in a.js.
var localValue = 'b'
// If a.js it run before b.js, now the globalData shoule be 2.
console.log(getApp().globalData)
```

## 模块化

我们可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 `module.exports` 或者 `exports` 才能对外暴露接口。

**需要注意的是：**

- `exports` 是 `module.exports` 的一个引用，因此在模块里边随意更改 `exports` 的指向会造成未知的错误。所以我们更推荐开发者采用 `module.exports` 来暴露模块接口，除非你已经清晰知道这两者的关系。
- 小程序目前不支持直接引入 `node_modules` , 开发者需要使用到 `node_modules` 时候建议拷贝出相关的代码到小程序的目录中。

```js
// common.js
function sayHello(name) {
  console.log(`Hello ${name} !`)
}
function sayGoodbye(name) {
  console.log(`Goodbye ${name} !`)
}

module.exports.sayHello = sayHello
exports.sayGoodbye = sayGoodbye
```

在需要使用这些模块的文件中，使用 require(path) 将公共代码引入
```js
var common = require('common.js')
Page({
  helloMINA: function() {
    common.sayHello('MINA')
  },
  goodbyeMINA: function() {
    common.sayGoodbye('MINA')
  }
})
```

## ES6 语法以及 API 支持

微信小程序运行在三端：iOS、Android 和 用于调试的开发者工具

- 在 iOS 上，小程序的 javascript 代码是运行在 JavaScriptCore 中
- 在 Android 上，小程序的 javascript 代码是通过 X5 内核来解析
- 在 开发工具上， 小程序的 javascript 代码是运行在 nwjs（chrome内核） 中

在 0.10.101000 以及之后版本的开发工具中，会默认使用 babel 将开发者代码 ES6 语法转换为三端都能很好支持的 ES5 的代码，帮助开发者解决环境不同所带来的开发问题。开发者可以在项目设置中关闭这个功能。

**需要注意的是：**

- 这种转换只会帮助开发处理语法上问题，新的 ES6 的 API 例如 Promise 等需要开发者自行引入 Polyfill 或者别的类库。
- 为了提高代码质量，在开启 ES6 转换功能的情况下，默认启用 javasctipt 严格模式，请参考 "use strict" 。

# 视图层

框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示。

将逻辑层的数据反应成视图，同时将视图层的事件发送给逻辑层。

WXML(WeiXin Markup language)用于描述页面的结构。

WXSS(WeiXin Style Sheet)用于描述页面的样式。

组件(Component)是视图的基本组成单元。

## 数据绑定

WXML 中的动态数据均来自对应 Page 的 data。

## 简单绑定

数据绑定使用 Mustache 语法（双大括号）将变量包起来，可以作用于：

内容
```html
<view> {{ message }} </view>
```
```js
Page({
  data: {
    message: 'Hello MINA!'
  }
})
```

### 组件属性(需要在双引号之内)
```html
<view id="item-{{id}}"> </view>
```

### 控制属性(需要在双引号之内)
```html
<view wx:if="{{condition}}"> </view>
```

### 关键字(需要在双引号之内)

true：boolean 类型的 true，代表真值。

false： boolean 类型的 false，代表假值。
```html
<checkbox checked="{{false}}"> </checkbox>
```

**特别注意：不要直接写 checked="false"，其计算结果是一个字符串，转成 boolean 类型后代表真值。**

### 运算
可以在 {{}} 内进行简单的运算，支持的有如下几种方式：

### 三元运算
```html
<view hidden="{{flag ? true : false}}"> Hidden </view>
```

### 算数运算
```html
<view> {{a + b}} + {{c}} + d </view>
```

### 逻辑判断
```html
<view wx:if="{{length > 5}}"> </view>
```

### 字符串运算
```html
<view>{{"hello" + name}}</view>
```

### 数据路径运算
```html
<view>{{object.key}} {{array[0]}}</view>
```

### 组合
也可以在 Mustache 内直接进行组合，构成新的对象或者数组。

### 数组
```html
<view wx:for="{{[zero, 1, 2, 3, 4]}}"> {{item}} </view>
```

### 对象
```html
<template is="objectCombine" data="{{for: a, bar: b}}"></template>
```
也可以用扩展运算符 ... 来将一个对象展开
```html
<template is="objectCombine" data="{{...obj1, ...obj2, e: 5}}"></template>
```

如果对象的 key 和 value 相同，也可以间接地表达。
```html
<template is="objectCombine" data="{{foo, bar}}"></template>
```

## 条件渲染
`wx:if`
在框架中，我们用 `wx:if="{{condition}}"` 来判断是否需要渲染该代码块：

也可以用 `wx:elif` 和 `wx:else` 来添加一个 `else` 块：

```html
<view wx:if="{{length > 5}}"> 1 </view>
<view wx:elif="{{length > 2}}"> 2 </view>
<view wx:else> 3 </view>
```

`block wx:if`
因为 `wx:if` 是一个控制属性，需要将它添加到一个标签上。但是如果我们想一次性判断多个组件标签，我们可以使用一个 <block/> 标签将多个组件包装起来，并在上边使用 wx:if 控制属性。
```html
<block wx:if="{{true}}">
  <view> view1 </view>
  <view> view2 </view>
</block>
```
**注意： `<block/> `并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。**
**`wx:if`在条件第一次变成真的时候才开始局部渲染。`hidden`组件始终会被渲染，只是简单的控制显示与隐藏**
**`wx:if` 有更高的切换消耗而 `hidden` 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 `hidden` 更好，如果在运行时条件不大可能改变则 `wx:if` 较好。**

## 列表渲染
`wx:for

在组件上使用wx:for控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。

默认数组的当前项的下标变量名默认为index，数组当前项的变量名默认为item`
```html
<view wx:for="{{array}}">
  {{index}}: {{item.message}}
</view>
```
```js
Page({
  data: {
    array: [{
      message: 'foo',
    }, {
      message: 'bar'
    }]
  }
})
```
使用 `wx:for-item` 可以指定数组当前元素的变量名，
使用 `wx:for-index` 可以指定数组当前下标的变量名：
```html
<view wx:for="{{array}}" wx:for-index="idx" wx:for-item="itemName">
  {{idx}}: {{itemName.message}}
</view>
```
`wx:for`也可以嵌套，下边是一个九九乘法表
```html
<view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="i">
  <view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="j">
    <view wx:if="{{i <= j}}">
      {{i}} * {{j}} = {{i * j}}
    </view>
  </view>
</view>
```

`block wx:for`

类似`block wx:if`，也可以将`wx:for`用在`<block/>`标签上，以渲染一个包含多节点的结构块。例如：
```html
<block wx:for="{{[1, 2, 3]}}">
  <view> {{index}}: </view>
  <view> {{item}} </view>
</block>
```

`wx:key`

如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如` <input/>` 中的输入内容，`<switch/>` 的选中状态），需要使用 `wx:key` 来指定列表中项目的唯一的标识符。

`wx:key` 的值以两种形式提供

1. 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。
2. 保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如：

当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。

**如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。**

**示例代码：**
```html
<switch wx:for="{{objectArray}}" wx:key="unique" style="display: block;"> {{item.id}} </switch>
<button bindtap="switch"> Switch </button>
<button bindtap="addToFront"> Add to the front </button>

<switch wx:for="{{numberArray}}" wx:key="*this" style="display: block;"> {{item}} </switch>
<button bindtap="addNumberToFront"> Add to the front </button>
```

```js
Page({
  data: {
    objectArray: [
      {id: 5, unique: 'unique_5'},
      {id: 4, unique: 'unique_4'},
      {id: 3, unique: 'unique_3'},
      {id: 2, unique: 'unique_2'},
      {id: 1, unique: 'unique_1'},
      {id: 0, unique: 'unique_0'},
    ],
    numberArray: [1, 2, 3, 4]
  },
  switch: function(e) {
    const length = this.data.objectArray.length
    for (let i = 0; i < length; ++i) {
      const x = Math.floor(Math.random() * length)
      const y = Math.floor(Math.random() * length)
      const temp = this.data.objectArray[x]
      this.data.objectArray[x] = this.data.objectArray[y]
      this.data.objectArray[y] = temp
    }
    this.setData({
      objectArray: this.data.objectArray
    })
  },
  addToFront: function(e) {
    const length = this.data.objectArray.length
    this.data.objectArray = [{id: length, unique: 'unique_' + length}].concat(this.data.objectArray)
    this.setData({
      objectArray: this.data.objectArray
    })
  },
  addNumberToFront: function(e){
    this.data.numberArray = [ this.data.numberArray.length + 1 ].concat(this.data.numberArray)
    this.setData({
      numberArray: this.data.numberArray
    })
  }
})
```

## 模板
WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。

### 定义模板

使用name属性，作为模板的名字。然后在<template/>内定义代码片段，如：

```html
<!--
  index: int
  msg: string
  time: string
-->
<template name="msgItem">
  <view>
    <text> {{index}}: {{msg}} </text>
    <text> Time: {{time}} </text>
  </view>
</template>
```

### 使用模板
使用 is 属性，声明需要的使用的模板，然后将模板所需要的 data 传入，如：

```html
<template is="msgItem" data="{{...item}}"/>
```

is 属性可以使用 Mustache 语法，来动态决定具体需要渲染哪个模板：
```html
<template name="odd">
  <view> odd </view>
</template>
<template name="even">
  <view> even </view>
</template>

<block wx:for="{{[1, 2, 3, 4, 5]}}">
    <template is="{{item % 2 == 0 ? 'even' : 'odd'}}"/>
</block>
```

**模板拥有自己的作用域，只能使用data传入的数据。**

## 事件

什么是事件

- 事件是视图层到逻辑层的通讯方式。
- 事件可以将用户的行为反馈到逻辑层进行处理。
- 事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。
- 事件对象可以携带额外信息，如 id, dataset, touches。

事件的使用方式

- 在组件中绑定一个事件处理函数。

如bindtap，当用户点击该组件的时候会在该页面对应的Page中找到相应的事件处理函数。
```html
<view id="tapTest" data-hi="WeChat" bindtap="tapName"> Click me! </view>
```

- 在相应的Page定义中写上相应的事件处理函数，参数是event。
```js
Page({
  tapName: function(event) {
    console.log(event)
  }
})
```

- 可以看到log出来的信息大致如下：
```js
{
"type":"tap",
"timeStamp":895,
"target": {
  "id": "tapTest",
  "dataset":  {
    "hi":"WeChat"
  }
},
"currentTarget":  {
  "id": "tapTest",
  "dataset": {
    "hi":"WeChat"
  }
},
"detail": {
  "x":53,
  "y":14
},
"touches":[{
  "identifier":0,
  "pageX":53,
  "pageY":14,
  "clientX":53,
  "clientY":14
}],
"changedTouches":[{
  "identifier":0,
  "pageX":53,
  "pageY":14,
  "clientX":53,
  "clientY":14
}]
}
```

## 事件详解

### 事件分类

事件分为冒泡事件和非冒泡事件：

1. 冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。
2. 非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。

WXML的冒泡事件列表：
类型  |  触发条件
--|--
touchstart  |  手指触摸动作开始
  touchmove|  手指触摸后移动
  touchcancel|  手指触摸动作被打断，如来电提醒，弹窗
  touchend|  手指触摸动作结束
  tap|  手指触摸后马上离开
  longtap|  手指触摸后，超过350ms再离开

**注：除上表之外的其他组件自定义事件如无特殊申明都是非冒泡事件，如`<form/>`的submit事件，`<input/>`的input事件，`<scroll-view/>`的scroll事件，(详见各个组件)**

### 事件绑定

事件绑定的写法同组件的属性，以 key、value 的形式。

- key 以bind或catch开头，然后跟上事件的类型，如bindtap, catchtouchstart
- value 是一个字符串，需要在对应的 Page 中定义同名的函数。不然当触发事件的时候会报错。

**bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。**

如在下边这个例子中，点击 inner view 会先后触发handleTap3和handleTap2(因为tap事件会冒泡到 middle view，而 middle view 阻止了 tap 事件冒泡，不再向父节点传递)，点击 middle view 会触发handleTap2，点击 outter view 会触发handleTap1。

```html
<view id="outter" bindtap="handleTap1">
  outer view
  <view id="middle" catchtap="handleTap2">
    middle view
    <view id="inner" bindtap="handleTap3">
      inner view
    </view>
  </view>
</view>
```

## 事件对象

如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。

**BaseEvent 基础事件对象属性列表：**
- type	String	事件类型
- timeStamp	Integer	事件生成时的时间戳
- target	Object	触发事件的组件的一些属性值集合
- currentTarget	Object	当前组件的一些属性值集合

**CustomEvent 自定义事件对象属性列表（继承 BaseEvent）：**
- detail	Object	额外的信息

**TouchEvent 触摸事件对象属性列表（继承 BaseEvent）：**
- touches	Array	触摸事件，当前停留在屏幕中的触摸点信息的数组
- changedTouches	Array	触摸事件，当前变化的触摸点信息的数组

**特殊事件： `<canvas/> `中的触摸事件不可冒泡，所以没有 currentTarget。**

### type
代表事件的类型。

### timeStamp
页面打开到触发事件所经过的毫秒数。

### target
触发事件的源组件。

- id	String	事件源组件的id
- tagName	String	当前组件的类型
- dataset	Object	事件源组件上由data-开头的自定义属性组成的集合


### currentTarget
- id	String	当前组件的id
- tagName	String	当前组件的类型
- dataset	Object	当前组件上由data-开头的自定义属性组成的集合


### dataset
在组件中可以定义数据，这些数据将会通过事件传递给 `SERVICE。` 书写方式： 以`data-`开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)如`data-element-type`，最终在 `event.target.dataset` 中会将连字符转成驼峰`elementType`。

```html
<view data-alpha-beta="1" data-alphaBeta="2" bindtap="bindViewTap"> DataSet Test </view>
```
```js
Page({
  bindViewTap:function(event){
    event.target.dataset.alphaBeta === 1 // - 会转为驼峰写法
    event.target.dataset.alphabeta === 2 // 大写会转为小写
  }
})
```

### touches
touches 是一个数组，每个元素为一个 Touch 对象（canvas 触摸事件中携带的 touches 是 CanvasTouch 数组）。 表示当前停留在屏幕上的触摸点。

### Touch 对象

- identifier	Number	触摸点的标识符
- pageX, pageY	Number	距离文档左上角的距离，文档的左上角为原点 ，横向为X轴，纵向为Y轴
- clientX, clientY	Number	距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴

### CanvasTouch 对象

- identifier	Number	触摸点的标识符
- x, y	Number	距离 Canvas 左上角的距离，Canvas 的左上角为原点 ，横向为X轴，纵向为Y轴

### changedTouches

changedTouches 数据格式同 touches。 表示有变化的触摸点，如从无变有（touchstart），位置变化（touchmove），从有变无（touchend、touchcancel）。

### detail

自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息，详见组件定义中各个事件的定义。


## 引用
WXML 提供两种文件引用方式import和include。

### import

`import`可以在该文件中使用目标文件定义的`template`，如：

在 item.wxml 中定义了一个叫item的template：

```html
<!-- item.wxml -->
<template name="item">
  <text>{{text}}</text>
</template>
```

在 index.wxml 中引用了 item.wxml，就可以使用item模板：

```html
<import src="item.wxml"/>
<template is="item" data="{{text: 'forbar'}}"/>
```

### import 的作用域

import 有作用域的概念，即只会 import 目标文件中定义的 template，而不会 import 目标文件 import 的 template。

**如：C import B，B import A，在C中可以使用B定义的template，在B中可以使用A定义的template，但是C不能使用A定义的template。**

### include
include可以将目标文件除了`<template/>`的整个代码引入，相当于是拷贝到include位置，如：

```html
<!-- index.wxml -->
<include src="header.wxml"/>
<view> body </view>
<include src="footer.wxml"/>
```

```html
<!-- header.wxml -->
<view> header </view>
```

```html
<!-- footer.wxml -->
<view> footer </view>
```

## WXSS

### 尺寸单位
- rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。
- rem（root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx 。

**建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。 注意： 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。**

### 样式导入
使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束。

### 内联样式
- style：静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度。
```html
<view style="color:{{color}};" />
```

- class：用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上.，样式类名之间用空格分隔。
```html
<view class="normal_view" />
```

### 选择器

目前支持的选择器有：
- .class	.intro	选择所有拥有 class="intro" 的组件
- #id	#firstname	选择拥有 id="firstname" 的组件
- element	view	选择所有 view 组件
- element, element	view, checkbox	选择所有文档的 view 组件和所有的 checkbox 组件
- ::after	view::after	在 view 组件后边插入内容
- ::before	view::before	在 view 组件前边插入内容

### 全局样式与局部样式
定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器
