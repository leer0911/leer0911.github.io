---
title: 设计原则和编程技巧
---

每种设计模式都是为了让代码迎合其中一个或多个原则而出现的，它们本身已经融入了设计模式之中,给面向对象编程指明了方向。

设计原则通常指的是单一职责原则,里氏替换原则,依赖倒置原则,接口隔离原则,合成复用原则和最少知识原则。

# 单一职责原则

就一个类而言,应该仅有一个引起它变化的原因。单一职责原则更多是被运用在对象或者方法级别上。单一职责原则(SRP)的职责被定义为'引起变化的原因'。

SRP原则体现为:一个对象(方法)只做一件事情。

## 设计模式中的SRP原则

SRP原则在很多设计模式中都有着广泛的运用，例如代理模式,迭代器模式,单例模式和装饰者模式。

1.代理模式

```javascript
var myImage = (function () {
    var imgNode = document.createElement('img');
    document.body.appendChild(imgNode);
    return {
      setSrc: function (src) {
        imgNode.src = src;
      }
    }
  })();

  var proxyImage = (function () {
    var img = new Image;
    img.onload = function () {
      myImage.setSrc(this.src);
    }
    return {
      setSrc: function (src) {
        myImage.setSrc('loading.gif')
        img.src = src;
      }
    }
  })();

  proxyImage.setSrc('a.jpg');
```

2.迭代器模式

```javascript
var each = function(obj, callback) {
    var value,
        i = 0,
        length = obj.length,
        isArray = isArraylike(obj);

    if (isArray) {
      for (; i < length; i++) {
        callback.call(obj[i],i,obj[i]);
      }
    } else{
      for (i in obj) {
        value = callback.call(obj[i],i,obj[i]);
      }
    }
    return obj;
};

var appendDiv = function (data) {
  each(data,function (i,n) {
    var div = document.createElement('div');
    div.innerHTML = n;
    document.body.appendChild(div);
  });
};

appendDiv([1,2,3])
appendDiv({a:1,b:2})
```

3.单例模式

```javascript
var getSingle = function (fn) {
    var result;
    return function () {
      return result || (result = fn.apply(this,arguments));
    }
  };

  var createLoginLayer = function () {
    var div = document.createElement('div');
    div.innerHTML = '我是登录浮窗';
    document.body.appendChild(div);
    return div;
  };

  var createSingleLoginLayer = getSingle(createLoginLayer);

  var loginLayer1 = createSingleLoginLayer();
  var loginLayer2 = createSingleLoginLayer();
```

4.装饰者模式

```html
<html>
    <body>
      <button tag="login" id="button">点击打开登录浮层</button>
    </body>
    <script type="text/javascript">
      Function.prototype.after = function (afterfn) {
        var __self = this;
        return function () {
          var ret = __self.apply(this,arguments);
          afterfn.apply(this,arguments);
          return ret;
        }
      }

      var showLogin = function () {
        console.log('打开登录浮层');
      };

      var log  =  function () {
        console.log('上级标签为'+this.getAttribute('tag'));
      };

      document.getElementById('button').onclick = showLogin.after(log);
    </script>
  </html>
```

## 何时应该分离职责

SRP原则是所有原则中最简单也是最难正确运用的原则之一。

要明确的是,并不是所有的职责都应该一一分离。

一方面,如果随着需求的变化,有两个职责总是同时变化,那就不必要分离他们。

另一方面,职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦合在一起，但他们还没有发生改变的征兆，那么也许没有必要主动分离他们。

## 违反SRP原则

在人的常规思维中，总是习惯性地把一组相关的行为放到一起，如何正确分离职责不是一件容易的事情。

在方便性与稳定性之间要有一些取舍。

## SRP原则的优缺点

SRP原则的优点是降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度，这有助于代码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他的职责。

SRP的缺点,最明显的是会增加编写代码的复杂度。当我们按照职责把对象分解成更小的粒度后,实际上也增大了这些对象之间相互联系的难度。

# 最少知识原则

最少知识原则(LKP)说的是一个软件实体应当尽可能少地与其他实体发生相互作用。这里的软件实体是一个广义的概念，不仅包括对象，还包括系统,类,模块,函数,变量等。

## 减少对象之间的联系

单一职责原则指导我们把对象划分成较小的粒度,这样可以提高对象的可复用性。但越来越多的对象之间可能会产生错综复杂的联系，如果修改了其中一个对象，很可能会影响到跟它相互引用的其他对象。

最少知识原则要求我们在设计程序时,应当尽量减少对象之间的交互。

## 封装在最少知识原则中的体现

封装在很大程度上表达的是数据的隐藏。一个模块或者对象可以将内部的数据或者实现细节隐藏起来，只暴露必要的接口API供外界访问。对象之间难免产生联系，当一个对象必须引用另外一个对象的时候,我们可以让对象只暴露必要的接口,让对象之间的联系限制最最小的范围之内。

封装也用来限制变量的作用域。

原则只是一种知道，没有哪条原则是在实际开发中必须遵守的。

# 开放封闭原则

在面向对象的程序设计中,开放封闭原则(OCP)是最重要的一条原则。很多时候,一个程序具有良好的设计,往往说明它是符合开放封闭原则的。

开放封闭原则定义:软件实体(类,模块,函数)等英国是可以扩展的,但是不可修改。

开放封闭原则的思想:当需要改变一个程序的功能或者给这个程序增加新功能的时候,可以使用增加代码的方式，但是不允许改动程序的源代码。

## 用对象的多态性消除条件分支

过多的条件分支语句时造成程序违反开放封闭原则的一个常见原因。每当需要增加一个新的if语句时，都要被迫改动原函数。把if换成switch-case是没用的。这是一种换汤不换药的做法。每当我们看到一大片的if或者switch-case语句时，第一时间就应该考虑,能否利用对象的多态性来重构它们。

利用对象的多态性来让程序遵守开放封闭原则,是一个常用的技巧。

多态的思想,把程序中不变的部分隔离出来，然后把可变的部分封装起来。

```javascript
var makeSound = function (animal) {
    animal.sound();
  };

  var Duck = function () {};
  Duck.prototype.sound = function () {console.log('gaga');}
```

## 找出变化的地方

找出程序中将要发生变化的地方,然后把变化封装起来。这样可以尽量遵守开放封闭原则。

通过封装变化的方式，可以把系统中稳定不变的部分和容易变化的部分隔离开来。在系统演变的过程中,
我们只需要替换那些容易变化的部分，如果这些部分是已经被封装好的，那么替换起来也相对容易。

还有其他方式:
1.放置挂钩

放置挂钩也是分离变化的一种方式。我们在程序有可能发生变化的地方放置一个挂钩，挂钩的返回结果决定了程序的下一步走向。
这样一来，原本的代码执行路径上就出现了一个分叉路口，程序未来的执行方向被预埋下多种可能性。

2.使用回调函数

在JavaScript中，函数可以作为参数传递给另一个函数，这是高阶函数的意义之一。在这种情况下,我们通常会把这个函数称为回调函数。

回调函数是一种特殊的挂钩。我们可以把一部分易于变化的逻辑封装在回调函数里。然后把回调函数当做参数传入一个稳定和封闭的函数中。

## 设计模式中的开放封闭原则

有一种说法是,设计模式就是给做的好的设计取个名字。

- 发布订阅模式
- 模板方法模式
- 策略模式
- 代理模式
- 职责链模式

## 开放封闭原则的相对性
开放封闭原则要求我们只能通过增加源代码的方式扩展程序的功能，而不允许修改源代码。

让程序符合开放封闭原则的代价是引入更多的抽象层次，更多的抽象可能会增大代码的复杂度。

- 挑选出最容易发生变化的地方,任何构造抽象来封闭这些变化。
- 在不可避免发生修改的时候，尽量修改哪些相对容易修改的地方。拿一个开源库来说,修改它提供的配置文件,总比修改它的源代码来得简单。

# 接口和面向接口编程

我们经常说一个库或者模块对外提供了某某API接口。通过主动暴露的接口来通信，可以隐藏软件系统内部的工作细节。

第二种接口是一些语言提供的关键字，比如java的interface。interface关键字可以产生一个完全抽象的类。这个完全抽象的类用来便是一种契约，专门负责建立类与类之间的联系。

第三种接口即是我们谈论的"面向接口编程"中的接口。

接口是对象能响应请求的集合。

面向接口编程，而不是面向实现编程。

从过程上来看,"面向接口编程"其实是"面向超类型编程"。当对象的具体类型被隐藏在超类型身后时，这些对象就可以相互替换使用，
我们的关注点才能从对象的类型上转移到对象的行为上。"面向接口编程"也可以看成面向抽象编程，即针对超类型中的abstract方法编程。

鸭子类型是动态类型语言面向对象设计中的一个重要概念。利用鸭子类型的思想。不必借助超类型的帮助，就能在动态语言类型中轻松实现本章提到的设计原则。

# 代码重构

模式和重构之间有着一种与生俱来的关系。设计模式的目的就是为许多重构行为提供目标。

如果有一个函数过长,不得不加上若干注释才能让这个函数显得易读一些,那这些函数就很有必要进行重构。


## 提炼函数

避免出现超大函数。

独立出来的函数有助于代码复用。

独立出来的函数更容易被覆写。

独立出来的函数如果拥有一个良好的命名，它本身就起到了注释作用。

## 合并重复的条件片段

## 把条件分支语句提炼成函数

## 合理使用循环

## 提前让函数退出代替嵌套条件分支

## 传递对象参数代替过长的参数列表

## 尽量减少参数数量

## 少用三目运算符

## 合理使用链式调用

## 分解大型类

## 用return退出多重循环
