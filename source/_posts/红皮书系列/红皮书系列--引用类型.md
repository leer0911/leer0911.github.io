---
title: 引用类型
---
引用类型的值是引用类型的一个实例。在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。 引用类型有时候也被称为对象定义，因为他们描述的是一类对象所具有的属性和方法。对象是某个特定的引用类型的实例。 新对象用new操作符后跟一个构造函数来创建。构造函数本身就是一个函数，只不过该函数时出于创建新对象的目的而定义的。

## Object类型
大多数引用类型值都是Object类型的实例；虽然不具备多少功能但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。 创建Object实例的方式有两种：
  * 第一种是使用new操作符后跟Object构造函数；
  * 第二种是用对象字面量的表示法；

## Array类型
数组的每一项可用来保存任何类型的数据，而且其大小是可以动态调整的。 创建方式有两种：
  * 第一种是使用new操作符后跟Object构造函数；
  * 第二种是用对象字面量的表示法；

  * ### 检测数组
  对于一个网页或者一个全局作用域而言，用instanceof操作符来检测`value instanceof Array`其问题在于，它假定只有一个全局执行环境。 如果网页包含多个框架，那实际上就存在两个以上不同版本的Array构造函数。ECMAScript新增了isArray()方法

  * ### 栈方法
  ECMAScript 数组也提供了一种让数组的行为类似于其他数据结构的方法。具体说来，数组可以表现得就像栈一样，后者是一种可以限制插入和删除项的数据结构。 栈是一种LIFO的数据结构，也就是最新添加的项最早被移除。而栈中项的插入(叫做推入)和移除(叫做弹出)，只发生在一个位置，栈的顶部。ECMAScript为数组 专门提供了push()和pop()方法，以便实现类似栈的行为。

  * ### 队列方法
  队列数据结构的访问规则是FIFO(先进先出)。队列在列表的末端添加项，从列表的前端移除项。实现这一操作的数组方法就是shift()，结合shift()和push()方法， 就可以像使用队列一样使用数组。

  * ### 重排序方法
  数组中已经存在连个直接用来重排序的方法reverse()和sort()。sort()是按升序的方式排列数组，为了实现排序，sort()会调用每个数组项的toString()转型方法。 即使数组中每一项都是数值，也是比较字符串。返回值是经过排序后的数组。

  * ### 操作方法
  concat()：基于当前数组中的所有项创建一个新数组。
  slice()：返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数则从起始位置和结束位置间的项(不包括结束位置的项)*不影响原始数组*
  splice()：主要用途是向数组的中部插入项，有3中方法：
  * 删除：可以删除任意项，只需指定2个参数：要删除的第一项位置和要删除的项数；
  * 插入：可以向指定位置插入任意项，只需提供3个参数：起始位置、0(要删除的项数)和要插入的项。
  * 替换：起始位置、要删除的项数和要插入的任意数量项。
  该方法始终会返回一个数组，该数组中包含从原始数组中删除的项如果没有删除任何项，则返回一个空数组。
    ```js
      var colors = ["red", "green", "blue"];
      var removed = colors.splice(0,1); // 删除第一项
      alert(colors); // green,blue
      alert(removed); // red，返回的数组中只包含一项
      removed = colors.splice(1, 0, "yellow", "orange"); // 从位置 1 开始插入两项
      alert(colors); // green,yellow,orange,blue
      alert(removed); // 返回的是一个空数组
      removed = colors.splice(1, 1, "red", "purple"); // 插入两项，删除一项
      alert(colors); // green,red,purple,orange,blue
      alert(removed); // yellow，返回的数组中只包含一项
    ```
  * ### 位置方法
    两个都接收参数，要查找的项和表示查找七点的位置索引。
    indexOf()：从数组开头开始；
    lastIndexOf()：从数组末尾开始；

  * ### 迭代方法
    定义了5中迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和运行该函数的作用域对象-影响this的值。传入这些方法的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。
    * every()：对数值中的每一项运行给定的函数，如果该函数对每一项都有返回true则返回true。
    * filter()：对数值中的每一项运行给定的函数，返回该函数会返回true的项组成的数组。
    * forEach()：对数组中的每一项运行给定的函数，这个方法没有返回值。
    * map()：对数组中的每一项运行给定的函数。返回每次函数调用的结果组成的数组。
    * some()：对数组中的每一项运行给定的函数，如果该函数对任一项返回true，则返回true。
    every和some最为相似，用于查询数组中的项是否满足某个条件。对于every()俩说，传入的函数
    必须对每一项都返回true，这个方法才返回true。而some()则只要有一项满足即返回true。

  ### 归并方法
  ECMAScript5新增了两个归并数组的方法：reduce()和reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。 reduce方法从数组第一项开始，逐个遍历到最后。而reduceRight()则从数组的最后一项开始，向前遍历到第一项。 这两个方法都接收两个参数：一个在每一项上调用的函数和左右归并基础的初始值。传给reducce和reduceRight的函数接收4个参数：前一个值、当前值、项的索引和数组对象。 这个函数返回的任何值都会作为第一个参数自动传给下一项。
    ```js
      var values = [1,2,3,4,5];
      var sum = values.reduce(function(prev, cur, index, array){
        return prev + cur;
      });
      alert(sum); //15
    ```

## Date类型

  * ### 日期格式化方法
   * toDateString()：以特定于实现的格式显示星期几、月、日和年；
   * toTimeString()：以特定于实现的格式显示时、分、秒和时区；
   * toLocaleDateString()
   * toLocaleTimeString()
   * toUTCString()

## RegExp类型
`var expression = /pattern/ flags ;` 其中模式(pattern)部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一个或 多个标志(flags)，用以表明正则表达式的行为。 正则表达式的匹配模式支持下列三个标志。
  * g：表示全局模式，即模式将应用于所有字符串，而非在发现第一个匹配项时立即停止；
  * i：表示不区分大小写模式；
  * m：表示多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在于模式匹配的项。
模式中所有的元字符都必须转义。正则表达式元字符包括：
`([{\^$|?*+.}])`
* RegExp实例属性：
  * global：布尔值，表示是否否设置了g标志。
  * ignoreCase：布尔值，表示是否设置了i标志。
  * mutiline：布尔值，表示是否设置了m标志。
  * lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。
  * source：正则表达式的字符串表示，按照字面量的形式而非传入构造函数中的字符串模式范湖。
* RegExp对象方法：
  * exec()是专门为捕获组而设计的。接收一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；
* RegExp构造函数属性
  包含一些属性，这些属性分别有一个长属性名和短属性名(Opera不支持短属性名)
  * input `$_` 最近一次要匹配的字符串
  * lastMatch `$&` 最近一次的匹配项
  * lastParen `$+` 最近一次的匹配的捕获组
  * leftContext `$`` input字符串中lastMatch之前的文本
  * multiline `$*` 是否为多行模式
  * rightContext `$'` input字符串中lastMatch之后的文本

## Function类型
函数实际上是对象，每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数时对象，因此函数名实际上也是一个指向 函数对象的指针，不会与某个函数绑定。函数通常是使用函数声明语法定义的。

  * ### 函数声明与函数表达式
  解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何 代码之前可用；基于函数表达式，则必须等到解析器执行到它所在的代码航，才会真正被解释执行

  * ### 作为值的函数
  因为ECMAScript中的函数名本身就是变量，所函数也可以作为值来使用。

  * ### 函数内部属性
  在函数内部有两个特殊的对象：argument和this，还有一个名叫callee的属性，该属性是一个指针，指向拥有中国argument对象的函数。 `argument.callee`ECMAScript5也规范了另一个函数对象的属性：caller。这个属性中保存着调用当前函数的引用，如果是在全局作用域中调用 当前函数，它的值为null为了实现更松散的耦合，可以通过`argument.callee.caller`来访问相同信息。

  * ### 函数的属性和方法
  ECMAScript中的函数时对象，因此函数也具有属性和方法。每个函数都有两个属性：length和prototype。其中，length属性表示函数希望接收的命名参数的个数 prototype属性无法枚举，因此使用for-in无法发现。 每个函数都包含两个非继承而来的方法，apply()和call()，这两个方法用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。首先，apply()方法接收两个参数：一个是在其中运行 函数的作用域，另一个是参数数组。其中第二个参数可以是Array实例，也可以是argument对象。最大作用在于改变函数作用域。使用call和apply来扩充作用域最大的好处，就是对象不再需要与方法有任何 耦合关系。ECMAScript5 还定义了一个方法：bind()。这个方法会创建一个函数的实例，其this会绑定到传给bind函数的值。

## 基本包装类型
为了方便操作基本类型值，ECMAScript还提供了3个特殊的引用类型:Boolean、Number和String。这些类型与本章 接收的其他引用类型相似。 *引用类型和基本包装类型的区别在于对象的生存期* 使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前一直都保存在内存中。 而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能运行时为基本类型值添加属性和方法。 对基本包装类型的实例调用typeof会返回Object，而且所有的基本包装类型的对象都会转换为布尔值true。
  * Boolean类型
  * Number类型
  * String类型
HTML方法专门用于简化常见HTML格式化任务的方法。需要注意的是他们创建的标记通常无法表达语义化。

## 单体内置对象
由ECMAScript实现提供的、不依赖于宿主环境的对象、这些对象在ECMAScript程序执行前就已经存在了。意思是 开发人员不必显式递实例化内置对象，因他们已经实例化了。Object、Array、String、Global、Math。
  * Global对象
  是一个终极的兜底儿对象，事实上没有全局对象和全局函数，所有全局作用域中定义的属性和函数都是Global对象的属性。
  eval()方法就像一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript字符串如果把执行结果插入到原位置。
  在eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在eval()执行的时候创建。
  * Math对象
  ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。
