---
title: 《JS高级程序》事件[1]
date: 2016-12-9
---
JavaScript与HTML的交互式通过事件实现的。事件，就是文档或浏览器窗口发生的一些特定的交互瞬间。可以使用侦听器(或处理程序)来预定事件

## 事件流
如同在一张纸上画一组同心圆，如果把手指放在圆心上，那么手指指向的就不是一个圆，而是纸上所有圆。事件流描述的是从页面中接收事件的顺序。IE的事件流是事件冒泡，儿Netscape的事件流是事件捕获。

*   ### 事件冒泡
    IE的事件流叫做事件冒泡，即事件开始由最具体的元素(文档中嵌套层次最深的那个节点)接收，然后逐级向上传播到较为不具体的节点(文档)。所有现代浏览器都支持事件冒泡，但实现上还是有一些差别。

*   ### 事件捕获
    事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于咋事件到达预定目标之前捕获它。尽管"DOM2级事件"规范要求事件应该从document对象开始传播，但这些浏览器都是从window对象开始捕获事件的。建议使用事件冒泡。

*   ### DOM事件流
    "DOM2级事件"规定的事件流包括三个阶段:事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件作出响应。

## 事件处理程序
事件就是用户或浏览器自身执行的某种动作。而响应某个事件的函数就叫做事件处理程序(或事件侦听器)。事件处理程序的名字以"on"开头，

*   ### HTML事件处理程序
    某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定。这个特性的值应该是能够执行的JavaScript代码。在HTML中定义的事件处理程序可以包含要执行的具体动作，也可以调用在页面其他地方定义的脚本。这样指定事件处理程序可以创建一个封装着元素属性的函数。这个函数中有一个局部变量event，也就就是事件对象。通过它可以直接访问事件对象，你不用自己定义它，在函数内部，this值等于事件的目标元素。

*   ### DOM0级事件处理程序
    通过JavaScript指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。要使用该事件处理程序，首先必须取得一个要操作的对象的引用。每个元素(包括window和document)都有自己的事件处理程序属性，这些属性通常全部要小写，将这种属性的值设置为一个函数就可以指定事件处理程序:
    ```js
      var btn = document.getElementById("myBtn");
      btn.onclick = function(){
        alert("a");
      }
    ```
    在此我们通过文档对象取得了一个按钮的引用，然后为它指定了onclick事件处理程序。可以通过`btn.onclick = null`删除DOM0级方法指定的事件处理程序。

*   ### DOM2级事件处理程序
    定义了两个方法，用于处理指定和删除事件处理程序的操作:addEventLisenter()和removeEventListener()。所有DOM节点中都包含着两个方法，并且他们都包含三个参数:要处理的事件名，作为事件处理程序的函数和一个布尔值。最后这个参数如果是true，表示在捕获阶段调用事件处理程序。如果是false，表示在冒泡阶段调用事件处理程序。使用DOM2级方法添加事件处理程序的主要好处是可以添加多个事件处理程序。
    ```js
    var btn = document.getElementById("myBtn");
    btn.addEventListenter("click",function(){
      alert(this.id);
    },false);
    btn.addEventListenter("click",function(){
      alert("hello world");
    },false);
    ```
    这里为按钮添加了两个事件处理程序。这两个事件处理程序会按照添加他们的顺序触发。通过使用removeEventListener()来移除添加的事件处理程序;移除时传入的参数与添加处理程序时使用的参数相同。
    ```js
    var btn = document.getElementById("myBtn");
    btn.addEventListenter("click",function(){
    alert(this.id);
    },false);
    btn.removeEventListener("click",function(){//无法移除匿名函数
    alert(this.id);
    },false);
    //可以通过函数表达式来实现
    var handler = function(){
    alert(this.id);
    }
    btn.addEventListener("click",handler,false);
    btn.removeEventListener("click",handler,false);
    ```
    大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需要，我们不建议在事件捕获阶段注册事件处理程序。

*   ### IE事件处理程序
    IE实现了与DOM中类似的两个方法:attachEvent()和detachEvent()。这两个方法接受两个参数:事件处理程序名称与事件处理程序函数。
    ```js
    var btn = document.getElementById("myBtn");
    btn.attachEvent("onclick",function(){
      alert(this.id);
    },false);
    ```
    注意在attachEvent()的第一个参数是"onclick";而非DOM的addEventListenter()方法中的"click"。如果调用两次attachEvent()，会以与添加顺序相反的顺序被触发。

*   ### 跨浏览器的事件处理程序

    为了以跨浏览器的方式处理事件，可以恰当地使用能力检测。第一个要创建的方法是addHandler()，它的职责是视情况分别使用DOM0级方法、DOM2级方法或IE方法来添加事件。这个方法属于一个名叫EventUtil的对象。

    ```js
    var EventUtil = {
        addHandler: function(element, type, handler) {
            if (element.addEventListener) {
                element.addEventListener(type, handler, false);
            } else if (element.attachEvent) {
                element.attachEvent("on" + type, handler);
            } else {
                element["on" + type] = handler;
            }
        },
        removeHandler: function(element, type, handler) {
            if (element.removeEventListener) {
                element.removeEventListener(type, handler, false);
            } else if (element.detachEvent) {
                element.detachEvent("on" + type, handler);
            } else {
                element["on" + type] = null;
            }
        }
    };
    ```
