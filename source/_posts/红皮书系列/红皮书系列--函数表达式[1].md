---
title: 《JS高级程序》函数表达式[1]
date: 2016-12-18
---
定义函数的方式有两种:一种是函数声明，另一种就是函数表达式。
  * 函数声明:
  ```js
    function functionName (arg0,arg1,arg2){
      //函数体
    }
  ```

  * 函数表达式:
  ```js
    var functionName = function(arg0,arg1,arg2){
      //函数体
    }
  ```
  这种情况下创建的函数叫匿名函数(也称拉姆达函数)匿名函数的那么熟悉是空字符串。函数表达式与其他表达式一样，在使用前必须先赋值。
  ```js
    // 不要这样做
    if(condition){
      function sayHi(){
        alert('Hi');
      }
    }else {
      function sayHi(){
        alert('yo');
      }
    }
    // 可以这样做
    if(condition){
      sayHi = function(){
        alert('Hi')
      }
    }else {
      sayHi = function(){
        alert('yo')
      }
    }
  ```
  在把函数当成值来使用的情况下，都可以使用匿名函数。

## 递归
递归函数时在一个函数通过名字调用自身的情况下构成的
```js
  function factor(num){
    if(num<=1){
      return 1;
    }else{
      return num * factor(num-1);
    }
  }
```
这是一个经典的递归阶乘函数。虽然表面看来没什么问题，但下面的代码却可能导致它出错。
```js
  var anterior = factor;
  factor = null;
  alert(anterior(4))//出错啦
```
可用argument.callee(是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用)解决，但在严格模式下，不能通过脚本访问argument.callee，访问中国属性会导致错误。可以使用命名函数表达式达成相同的结果。
```js
  var factor = (function f(num){
    if(num <= 1){
      return 1;
    }else{
      return num * f(num-1);
    }
  })
```

## 闭包
闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的最常见方式，就是在一个函数内部创建另一个函数。当某个函数被调用时，会创建一个执行环境及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的活动对象。由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多。

 * ### 闭包和变量
 作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。

 * ### 私有变量
 严格来讲，JavaScript没有私有成员的概念;所有的对象属性都是公有的。有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能再函数外部方位这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其他变量:
 ```js
  function add(num1,num2){
    var sum = num1 + num2;
    return sum;k
  }
 ```
 这个函数内部的变量外部无法访问，如果在函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量。而利用这一点，就可以创建用于访问私有变量的共有方法。这种方法称为*特权方法*有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法，基本模式如下。
 ```js
  function MyObject(){
    //私有变量和私有函数
    var privatevariable = 10;
    function privateFunction(){
      return false;
    }

    //特权方法
    this.publicMethod = function(){
      privateVariable ++;
      return privateFunction();
    }
  }
 ```
 特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。在创建MyObject实例后，除了使用publicMethod()这个途径外，没有任何方法可以直接访问到函数内的私有变量。利用私有和特权成员，可以隐藏那些不应该被直接修改的数据:
 ```js
  function Person(name){
    this.getName = function(){
      return name;
    };
    this.setName = function(value){
      name = value;
    }
  }
  var person = new Person("a");
  person.setName('b');
 ```
