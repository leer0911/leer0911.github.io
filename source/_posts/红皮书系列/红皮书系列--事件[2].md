---
title: 《JS高级程序》事件[2]
date: 2016-12-8
---
## 事件对象
在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如，鼠标操作导致的事件对象中，会包含鼠标位置的信息，而键盘操作导致的事件对象中，会包含与按下键有关的信息。所有浏览器都支持event但支持方式不同。

*   ### DOM中的事件对象
    兼容DOM的浏览器会将一个event对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法(DOM0级或DOM2级)，都会传入event对象。
*   bubbles 是否冒泡
*   cancelable 是否可以取消事件的默认行为
*   currentTarget 其事件处理程序当前正在处理事件的元素
*   defaultPrevent true表示已经调用了preventDefault()(DOM3级事件中新增)
*   detail 与事件相关的细节信息
*   eventPhase 调用事件处理程序的阶段:1表示捕获阶段2表示处于目标3表示冒泡阶段
*   preventDefault() 取消事件的默认行为。
*   stopImmediatePropagation() 取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用(DOM3级事件中新增)
*   stopPropagation() 取消事件的进一步捕获或冒泡。
*   target 事件的目标
*   trusted 为true表示事件是浏览器生成的。为false表示事件是由开发人员通过JavaScript创建的(DOM3级事件新增)
*   type 被触发的事件的类型
*   view 与事件关联的抽象视图。等同于发生事件的window对象
    如果需要通过一个函数处理多个事件时，可以使用type属性。例如:
    ```js
      var btn = document.getElementById("myBtn");
      var handler = function(event){
        switch(event.type){
          case "click":
            alert("clicked");
            break;
          case "mouseover":
            alert("mouseover");
            break;
          case "mouseout":
            alert("mouseout");
            break;
        }
      };
      btn.onclick = handler;
      btn.onmouseover = handler;
      btn.onmouseout = handler;
    ```
    可以使用preventDefault()方法阻止默认行为:
    ```js
      var link = document.getElementById("myLink");
      link.onclick = function(){
        event.preventDefault();
      }
    ```
    可以使用stopPropagation()取消进一步的事件捕获或冒泡。
    ```js
      var btn = document.getElementById("myBtn");
      btn.onclick =  function(event){
        alert("clicked");
        event.stopPropagation();
      }
      document.body.onclick = function(event){
        alert("body clicked");
      }
    ```
    只有在事件处理程序执行期间，event对象才会存在;一旦事件处理程序执行完成，event对象就会被销毁。

*   ### IE中的事件对象
    如果是通过HTML特性指定的事件处理程序，可以用一个名叫event的变量来访问event对象。
*   cancelBubble 设置为true就可以取消事件冒泡
*   returnValue 将其设置为false就可以取消事件的默认行为
*   srcElement 事件的目标
*   type 被处罚的事件类型
    因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为this会始终等于事件目标。故而，最好还是使用event.srcElement比较保险。
    ```js
      var btn = document.getElementById("myBtn");
      btn.onclick =  function(event){
        alert(window.event.srcElement === this)//true
      };
      btn.attachEvent("onclick",function(event){
        alert(window.event.srcElement === this)//true
      });
    ```
    设置cancelBubble为true则可以取消事件冒泡:
    ```js
    var btn = document.getElementById("myBtn");
    btn.onclick =  function(event){
      alert("clicked");
      window.event.cancelBubble = true;
    }
    document.body.onclick = function(event){
      alert("body clicked");
    }
    ```

*   ### 跨浏览器的事件对象
    ```js
    var EventUtil = {
        addHandler: function(element, type, handler) {
            //省略的代码
        },
        getEvent: function(event) {
            return event ? event : window.event;
        },
        getTarget: function(event) {
            return event.target || event.srcElement;
        },
        preventDefault: function(event) {
            if (event.preventDefault) {
                event.preventDefault();
            } else {
                event.returnValue = false;
            }
        },
        removeHandler: function(element, type, handler) {
            //省略的代码
        },
        stopPropagation: function(event) {
            if (event.stopPropagation) {
                event.stopPropagation();
            } else {
                event.cancelBubble = true;
            }
        }
    };
    ```
