---
title: 面向对象的程序设计
---
定义函数的方式有两种:一种是函数声明，另一种就是函数表达式。
  * 函数声明:
  ```js
    function functionName (arg0,arg1,arg2){
      //函数体
    }
  ```

  * 函数表达式:
  ```js
    var functionName = function(arg0,arg1,arg2){
      //函数体
    }
  ```
  这种情况下创建的函数叫匿名函数(也称拉姆达函数)匿名函数的那么熟悉是空字符串。函数表达式与其他表达式一样，在使用前必须先赋值。
  ```js
    // 不要这样做
    if(condition){
      function sayHi(){
        alert('Hi');
      }
    }else {
      function sayHi(){
        alert('yo');
      }
    }
    // 可以这样做
    if(condition){
      sayHi = function(){
        alert('Hi')
      }
    }else {
      sayHi = function(){
        alert('yo')
      }
    }
  ```
  在把函数当成值来使用的情况下，都可以使用匿名函数。

## 递归
递归函数时在一个函数通过名字调用自身的情况下构成的
```js
  function factor(num){
    if(num<=1){
      return 1;
    }else{
      return num * factor(num-1);
    }
  }
```
这是一个经典的递归阶乘函数。虽然表面看来没什么问题，但下面的代码却可能导致它出错。
```js
  var anterior = factor;
  factor = null;
  alert(anterior(4))//出错啦
```
可用argument.callee(是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用)解决，但在严格模式下，不能通过脚本访问argument.callee，访问中国属性会导致错误。可以使用命名函数表达式达成相同的结果。
```js
  var factor = (function f(num){
    if(num <= 1){
      return 1;
    }else{
      return num * f(num-1);
    }
  })
```

## 闭包
闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的最常见方式，就是在一个函数内部创建另一个函数。当某个函数被调用时，会创建一个执行环境及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的活动对象。由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多。

 * ### 闭包和变量
 作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。

 * ### 私有变量
 严格来讲，JavaScript没有私有成员的概念;所有的对象属性都是公有的。有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能再函数外部方位这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其他变量:
 ```js
  function add(num1,num2){
    var sum = num1 + num2;
    return sum;k
  }
 ```
 这个函数内部的变量外部无法访问，如果在函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量。而利用这一点，就可以创建用于访问私有变量的共有方法。这种方法称为*特权方法*有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法，基本模式如下。
 ```js
  function MyObject(){
    //私有变量和私有函数
    var privatevariable = 10;
    function privateFunction(){
      return false;
    }

    //特权方法
    this.publicMethod = function(){
      privateVariable ++;
      return privateFunction();
    }
  }
 ```
 特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。在创建MyObject实例后，除了使用publicMethod()这个途径外，没有任何方法可以直接访问到函数内的私有变量。利用私有和特权成员，可以隐藏那些不应该被直接修改的数据:
 ```js
  function Person(name){
    this.getName = function(){
      return name;
    };
    this.setName = function(value){
      name = value;
    }
  }
  var person = new Person("a");
  person.setName('b');
 ```
 * #### 静态私有变量
 通过在私有作用域中定义私有变量和函数，同样也可以创建特权方法，其基本模式:
 ```js
  (function(){
    // 私有变量和私有函数
    var privatevariable = 10;
    function privateFunction(){
      return false;
    }
    构造函数
    MyObject = function(){

    };

    // 公有特权方法
    MyObject.prototype.publicMethod = function(){
      privateVariable ++;
      return privateFunction();
    }
  })();
 ```
 这种模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。再私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数机器公有方法。公有方法是在其原型上定义的，这一点体现了典型的原型模式。这种模式与在构造函数中定义特权方法的主要区别，就在于私有变量和函数是由实例共享的。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。以这种方式创建静态私有变量会因为使用原型增进代码服用，但每个实例都么有自己的私有变量。

 * #### 模块模式
 前面两种模式是用于为自定义类型创建私有变量和特权方法的。而模块模式则是为单例创建私有变量和特权方法。所谓单例，指的就是只有一个实例的对象。就JavaScript是以对象字面量的方式来创建单例对象的。
 ```js
  var singleton = {
    name:value,
    method:function(){
      // 这里是方法的代码
    }
  }
 ```
 模块模式通过给单例添加私有变量和特权方法能够使其得到增强
 ```js
  var singleton = function() {
    // 私有变量和私有函数
    var privatevariable = 10;
    function privateFunction(){
      return false;
    }
    return{
      privateVariable ++;
      return privateFunction();
    }
  }
 ```
 这个模块模式使用了一个返回对象的匿名函数。这个范湖的对象字面量定义的是单例的公共接口。这个模式需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的:
 ```js
  var application = function(){
    // 私有变量和函数
    var component = new Array();
    // 初始化
    component.push(new BaseComponent());
    // 公共
    return {
      getComponentCount: function(){
        return component.length;
      },
      registerComponent: function(){
        if(typeof component == "Object"){
          component.push(component);
        }
      }
    }
  }
 ```
 简言之，如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么久可以使用模块模式。以这种模式创建的每个单例都是Object的实例，因为最终要通过一个对象字面量来表示它。

 * #### 增强的模块模式
 该模式使用于单例必须是某种类型的实例，同事还必须添加某些属性或方法对其加以增强的情况。
 ```js
  var singleton = function(){
    // 私有变量和私有函数
    var privatevariable = 10;
    function privateFunction(){
      return false;
    }
    // 创建对象
    var Object = new CustomType();

    // 添加特权/公有属性和方法
    Object.publicProperty = true;
    Object.publicMethod = function(){
      privateVariable ++;
      return privateFunction();
    }

    // 返回这个对象
    return Object;
  }
 ```

## 小结
* 递归函数应该始终使用argument.callee来递归地调用自身，不要使用函数名，函数名可能发生变化
* 当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量:
   * 在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域。
   * 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁，但是函数返回了一个闭包是，这个函数的作用域将会一直在内存中保存到闭包不存在为止。
* 使用闭包可以在JavaScript中模仿块级作用域
  * 创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。
  * 结果就是函数内部的所有变量都会被立即销毁，除非将某些变量赋值给了包含作用域中的变量。
* 闭包还可以用于在对象中创建私有变量，相关概念和药店如下。
  * 即使JavaScript中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量。
  * 有权访问私有变量的公有方法叫做特权方法。
  * 可以使用构造函数模式、原型模式、来实现自定义的特权方法，也可以使用模块模式和增强模块模式来实现单例的特权方法。   
