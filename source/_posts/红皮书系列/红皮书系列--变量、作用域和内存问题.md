---
title: 变量、作用域和内存问题
---
任何语言的核心都必然会描述这门语言的最基本的工作原理。ECMA-262通过叫做ECMAScript的“伪语言”来描述JavaScript的基本概念。

## 基本类型和引用类型的值

ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。
引用类型的值是保存在内存中的对象。JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象
的引用而不是实际的对象。

* ### 动态属性
只能给引用类型动态添加属性，以便将来使用。

* ### 复制变量值
基本类型复制是独立的，引用类型复制将指向同一对象，对任意一个对象赋值都将影响另一个变量副本。

* ### 传递参数
参数只能按值传递，引用类型同参数传递后其指向对象在堆内存中只有一个，而且是全局对象。
```js
  // 按值传递
  function setName(obj) {
    obj.name = "Nicholas";
    obj = new Object();
    obj.name = "Greg";
  }
  var person = new Object();
  setName(person);
  alert(person.name); //"Nicholas"
```
* ### 检测类型
要检测一个变量是不是基本数据类型，typeof操作符是最佳的工具。但在检测引用类型时这个操作符用处不大。通常我们并不是想知道某个值是对象，而是
想知道它是什么类型的对象。为此，ECMAScript提供了instanceof操作符，其语法：`result = variable instanceof constructor`根据规定所有引
用类型的值都是Object的实例。因此，在检测一个引用类型值和Object构造函数时，instanceof操作符始终会返回true。
*使用typeof检测正则表达式时返回的的是function*

## 执行环境及作用域
执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。
全局执行环境是最外围的一个执行环境。根据ECMAScript实现所在的宿主环境不用，表示执行环境的对象也不一样。在web浏览器中，全局执行环境被认为是window对象，
因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁
(全局执行环境知道应用程序退出，例如关闭网页或浏览器时才会被销毁)。
每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。
而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 ECMAScript 程序中的执行流
正是由这个方便的机制控制着。
当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是
保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所
在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对
象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中
的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延
续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。
标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，
然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。
*内部环境可以通过作用域链访问所有的外部环境。函数参数也被当做变量来对待，因此其访问规则与执行环境中的其他变量相同*
* ### 延长作用域链
虽然执行环境的类型总共只有两种：全局和局部(函数)，可以通过在作用域链的前端临时增加一个变量对象来延长作用域链。该变量
对象会在代码执行后被移除。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长：
 * try-catch语句的catch块；
 * with语句。
这两个语句都会在作用域链的前端添加一个变量对象。

* ### 没有块级作用域
JavaScript没有块级作用域。
 * #### 声明变量
 使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。

 * #### 查询标识符
 当某个执行环境中为了读取或写入二引用了一个标识符时，必须通过搜索来确定标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字
 匹配的标识符。如果在局部环境中找到了该表示符，搜索停止，变量就绪。访问局部变量比访问全局变量更快。

## 垃圾收集
  JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。原理是：找出那些不再继续使用的变量，然后释放其占用的内存。
垃圾收集器会安装固定的时间间隔周期性地执行这一操作。局部变量只在函数执行的过程中存在，再找个过程中，会为局部变量在栈(或堆)内存上分配相应的空间，
以便存储它们的值。
  标识无用变量的策略：
   * ### 标记清除
   当变量进入环境时，就将找个变量标记为“进入环境”。逻辑上讲，永远不能释放进入环境的变量所占用的内存，当离开环境时，则将其标记为“离开环境”
   * ### 引用计数
   跟踪记录每个值被引用的次数。
   * ### 管理内存
   确保浏览器占用最少的内存可以让页面获得更好的性能。二优化内存占用最佳方式就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其设置为Null来释放其
   引用。这个方法叫做接触引用。这个做法使用于大多数全局变量和全局对象的属性。局部变量会在他们离开执行环境时自动被解除引用。解除引用并不意味着自动回收该值所占的内存。
   解除引用的真正作用是让值脱离执行环境，以便来及收集器下次运行时将其回收。
