---
title: 《JS高级程序》引用类型[2]
date: 2016-12-23
---
## Function类型
函数实际上是对象，每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数时对象，因此函数名实际上也是一个指向 函数对象的指针，不会与某个函数绑定。函数通常是使用函数声明语法定义的。

*   ### 函数声明与函数表达式
    解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何 代码之前可用；基于函数表达式，则必须等到解析器执行到它所在的代码航，才会真正被解释执行

*   ### 作为值的函数
    因为ECMAScript中的函数名本身就是变量，所函数也可以作为值来使用。

*   ### 函数内部属性
    在函数内部有两个特殊的对象：argument和this，还有一个名叫callee的属性，该属性是一个指针，指向拥有中国argument对象的函数。 `argument.callee`ECMAScript5也规范了另一个函数对象的属性：caller。这个属性中保存着调用当前函数的引用，如果是在全局作用域中调用 当前函数，它的值为null为了实现更松散的耦合，可以通过`argument.callee.caller`来访问相同信息。

*   ### 函数的属性和方法
    ECMAScript中的函数时对象，因此函数也具有属性和方法。每个函数都有两个属性：length和prototype。其中，length属性表示函数希望接收的命名参数的个数 prototype属性无法枚举，因此使用for-in无法发现。 每个函数都包含两个非继承而来的方法，apply()和call()，这两个方法用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。首先，apply()方法接收两个参数：一个是在其中运行 函数的作用域，另一个是参数数组。其中第二个参数可以是Array实例，也可以是argument对象。最大作用在于改变函数作用域。使用call和apply来扩充作用域最大的好处，就是对象不再需要与方法有任何 耦合关系。ECMAScript5 还定义了一个方法：bind()。这个方法会创建一个函数的实例，其this会绑定到传给bind函数的值。

## 基本包装类型
为了方便操作基本类型值，ECMAScript还提供了3个特殊的引用类型:Boolean、Number和String。这些类型与本章 接收的其他引用类型相似。 *引用类型和基本包装类型的区别在于对象的生存期* 使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前一直都保存在内存中。 而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能运行时为基本类型值添加属性和方法。 对基本包装类型的实例调用typeof会返回Object，而且所有的基本包装类型的对象都会转换为布尔值true。
*   Boolean类型
*   Number类型
*   String类型
HTML方法专门用于简化常见HTML格式化任务的方法。需要注意的是他们创建的标记通常无法表达语义化。

## 单体内置对象
由ECMAScript实现提供的、不依赖于宿主环境的对象、这些对象在ECMAScript程序执行前就已经存在了。意思是 开发人员不必显式递实例化内置对象，因他们已经实例化了。Object、Array、String、Global、Math。
*   Global对象
  是一个终极的兜底儿对象，事实上没有全局对象和全局函数，所有全局作用域中定义的属性和函数都是Global对象的属性。
  eval()方法就像一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript字符串如果把执行结果插入到原位置。
  在eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在eval()执行的时候创建。
*   Math对象
  ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。
