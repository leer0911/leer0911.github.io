---
title: 《JS高级程序》事件[4]
date: 2016-12-6
---
* ### 更多的事件信息
detail属性给出有关事件的更多信息。其保护了一个数值，表示在给定位置上发生了多少次单击。detail属性从1开始计数，每次单击发生后都会递增。如果鼠标在mousedown和mouseup之间移动了位置，则detail被重置为0。
 * altLeft:表示是否按下了Alt键。
 * ctrlLeft:表示是否按下了Ctrl键。
 * offsetX:光标相对于目标元素边界的x坐标。
 * offsetY:光标相对于目标元素边界的y坐标。
 * shiftLeft:表示是否按下了Shift键。
 只有IE支持他们

* ### 鼠标滚轮事件
当用户通过鼠标滚轮与页面交互，在垂直方向上滚动页面时，就会触发mousewheel事件。这个事件可以在任何元素上面触发，最终会冒泡到document或window对象。与mousewheel事件对于的event对象除包含鼠标事件的所有标准信息外，还包含一个特殊的wheelDelta属性。当用户向前滚动鼠标滚轮时，wheelDelta是120的倍数;当用户向后滚动滚轮时，wheelDelta是-120的倍数。DOMMouseScroll是Firefox支持的类似事件。

## 键盘与文本事件
DOM3级事件为键盘事件制定了规范:
  * keydown 当用户按下键盘时触发，而且如果按住不放的话，会重复触发此事件。
  * keypress 当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件。按下Esc键也会触发这个事件。
  * keyup 当用户释放键盘上的键时触发。
  只有一个文本事件:textInput。这个事件是对keypress的补充。用意是将文本显示给用户之前更容易拦截文本。主要考虑的是字符，因此它的event对象中还包含一个data属性，这个属性值就是用户输入的字符。
```js
  var textbox = documen.getElementById("myText");
  EventUtil.addHandler(textbox,"textInput",function(event){
    event = EventUtil.getEvent(event);
    alert(event.data);
  })
```
event对象上还有一个属性，叫inoutMethod:
 * 0 表示浏览器不确定是怎么输入的。
 * 1 表示是使用键盘输入的。
 * 2 表示文本是粘贴进来的。
 * 3 表示是拖放进来的。
 * 4 表示文本是使用IME输入的。
 * 5 表示文本是通过在表单中选择某一项输入的。
 * 6 表示文本是通过手写输入的(比如使用手写笔)。
 * 7 表示文本是通过语音输入的。
 * 8 表示文本是通过几种方法组合输入的。
 * 9 表示文本是通过脚本输入的。

## 复合事件
有以下三种复合事件:
 * compositionstart:在IME的文本复合系统打开是触发，表示开始要输入。
 * compositionupdate:在向输入字段中插入新字符时触发。
 * compositionedn:表示返回正常的键盘输入状态。

## 变动事件
DOM2级定义了如下变动事件:
 * DOMSubtreeModified:在DOM结构中发生任何变化时触发。这个事件在其他任何事件触发后都会触发。
 * DOMNodeInserted:在一个节点作为子节点被插入到另一个节点时触发。
 * DOMNodeRemoved:在节点ongoing其父节点中被移除时触发。
 * DOMNodeInsertedIntoDocument:在一个节点被直接从文档中移除或通过子树间接从插入文档之后触发。这个事件在DOMNodeInserted之后触发。
 * DOMNodeRemovedFromDocument:在一个节点被直接从文档中移除或通过子树间接从文档中移除之前触发。这个事件在DOMNodeRemoved之后触发。
 * DOMAttrModified:在特性被修改之后触发。
 * DOMCharaterDataModified:在文本节点的值发生变化时触发。
使用`var isSupport = document.implementation.hasFeature("MutationEvents","2.0")`检测浏览器是否支持变动事件。

## HTML5事件
  * ### contextmenu事件
  上下文菜单事件，是冒泡的，因此可以为document指定一个事件处理程序，用以处理页面中发生的所有此类事件。
```js
EventUtil.addHandler(window, "load", function(event) {
    var div = document.getElementById("myDiv");
    EventUtil.addHandler(div, "contextmenu", function(event) {
        event = EventUtil.getEvent(event);
        EventUtil.preventDefault(event);
        var menu = document.getElementById("myMenu");
        menu.style.left = event.clientX + "px";
        menu.style.top = event.clientY + "px";
        menu.style.visibility = "visible";
    });
    EventUtil.addHandler(document, "click", function(event) {
        document.getElementById("myMenu").style.visibility = "hidden";
    });
});
```

* ### beforeunloa事件
之所以有此类事件，是为了让开发人员有可能在页面卸载前阻止这一操作。这个事件会在浏览器卸载页面之前触发，可以通过它来取消卸载并继续使用原有的页面。
```js
EventUtil.addHandler(window, "beforeunload", function(event) {
    event = EventUtil.getEvent(event);
    var message = "I'm really going to miss you if you go.";
    event.returnValue = message;
    return message;
});
```

* ### DOMContentLoaded事件
如果使用window的load事件会在页面中的一切都加载完毕时触发，而DOMContentLoaded事件则在形成完整的DOM树之后就会触发，不例会图像，JavaScript文件等是否已经下载完毕。

* ### readystatechange事件
这个事件的目的是提供与文档或元素的加载状态有关的信息，支持该事件的每个对象都有一个readystate属性:
 * uninitialized(未初始化): 对象存在但尚未初始化。
 * loading(正在加载):对象正在加载数据。
 * loaded(加载完毕)
 * interactive(交互):可以操作对象了，但是还没有完全加载。
 * complete(完成):对象已经加载完毕。

* ### pageshow和pagehide事件
个别浏览器带有前进后退缓存，那么当前进和后退时就不会触发load事件，此时可以使用pageshow事件来解决load需求。
```js
  (function(){
    var showCount = 0;
    EventUtil.addHandler(window,"load",function(){
      alert("Load fired");
    })
    EventUtil.addHandler(window,"pageshow",function(){
      showCount++;
      alert("show has been fired" + showCount + "times");
    });
  })();
```

* ### hashchange事件
以便在URL的参数列表(及URL中"#"号侯曼的所有字符串)发生变化时通知开发人员。之所以增加这个事件，是因为在Ajax应用中，开发人员经常要利用URL参数列表来保存状态或导航信息。必须要把hashchange事件处理程序添加给window对象，然后URL参数列表只要变化就会调用它。此时的event对象应该额外包含两个属性:oldURL和newURL。由于浏览器支持情况各异，推荐使用location对象来确定当前的参数列表。
```js
EventUtil.addHandler(window,"hashchange",function(event){
  alert("Current hash:" + location.hash);
})
```

* ### 设备事件
设备事件(device event)可以让开发人员确定用户在怎样使用设备。
 * #### orientationchange事件
 window.orientation包含三个属性:0表示肖像模式，90表示向左旋转的横向模式("主屏幕"按钮在右侧)，-90表示向右旋转的横向模式("主屏幕"按钮在左侧)
 ```js
  EventUtil.addHandler(window,"load",function(event){
    var div = document.getElementById("myDiv");
    div.innerHTML = "current orientation is" + window.orientation;
    EventUtil.addHandler(window,"orientationchange",function(event){
      div.innerHTML = "current orientation is" + window.orientation;
    })
  })
 ```

 * #### MozOrientation事件
 Firefox为该事件设置了3个属性:x，y，和z。这几个属性的值都介于1到-1直接，表示不同坐标轴上的方向。在静止状态下，x值为0，y值为0，z的值为1(表示设备处于竖直状态)。如果设备向右倾斜，x值会减小;反之，向左倾斜，x值会增大。类似地，如果设备向远离用户的方向倾斜，y值会减小，向接近用户的方向倾斜y值会增大。z轴检测垂直加速度，1表示静止不动，在设备移动时值会减小。(失重状态下值为0)

 * #### deviceorientation事件
  * alpha 在围绕z轴旋转时(即左右旋转时)，y轴的度数差;是一个介于0到360之间的浮点数。
  * beta 在围绕x轴旋转时(即前后旋转时)，z轴的度数差;是一个介于-180到180之间的浮点数。
  * gamma 在围绕y轴旋转时(即扭转设备时)，z轴的度数差;是一个介于-90到90的之间的浮点数。
  * absolute 表示设备是否返回一个绝对值。
  * compassCalibrated 表示设备的指南针是否校准过。
  通过这些信息，可以响应设备的方向，重新排列或修改屏幕上的元素。要响应设备方向的改变而旋转元素可以参考如下代码:
  ```js
  EventUtil.addHandler(window, "deviceorientation", function(event){
    var arrow = document.getElementById("arrow");
    arrow.style.webkitTransform = "rotate(" + Math.round(event.alpha) + "deg)";
  });
  ```
  只能用于移动webkit浏览器中，因为他使用了专有的webkitTransform。

* #### devicemotion事件
DeviceOrientation Event规范定义了devicemotion事件。这个事件是要告诉开发人员设备什么时候移动，而不仅仅是设备方向如果改变。通过devicemotion能够坚持到设备是不是正在往下掉，或者是不是被走着的人拿在手里。
 * acceleration: 一个包含x、y和z属性的对象，在不考虑重力的情况下，告诉你在每个方向上的加速度。
 * accelerationIncludingGravity: 一个包含x、y和z的属性的对象，在考虑z轴自然重力加速度的情况下，告诉你在每个方向上的加速度。
 * interval: 以毫秒表示的时间值，必须在另一个devicemotion事件触发前传入。
 * rotationRate 一个包含表示方向的alpha、beta和gamma属性的对象。
 ```js
 EventUtil.addHandler(window, "devicemotion", function(event) {
     var output = document.getElementById("output");
     if (event.rotationRate !== null) {
         output.innerHTML += "Alpha=" + event.rotationRate.alpha + ", Beta=" +
             event.rotationRate.beta + ", Gamma=" +
             event.rotationRate.gamma;
     }
 });
 ```

* ### 触摸与手势事件
Touch Event规范
 * #### 触摸事件
 触摸事件会在用户手指放在屏幕上面时、在屏幕上滑动时或从屏幕上移开时触发。
  * touchstart 当手指触摸屏幕时触发;即使已经有一个手指放在了屏幕上也会触发。
  * touchmove 当手指在屏幕上滑动时连续地触发。在这个事件发生期间，调用preventDefault()可以阻止滚动。
  * touchend 当手指从屏幕上移开时触发。
  * touchcancel 当系统停止跟踪触摸时触发。
  上面几个事件都会冒泡，也都可以取消。虽然这些触摸事件没有在DOM规范中定义，但他们却是以兼容DOM的方式实现的。因此，每个触摸事件的event对象都提供了在鼠标事件中常见的属性:bubbles，cancelable，view，clientX，clientY，screenX，screenY，detail，altKey，shiftkey，ctrlKey，和metaKey。
  除了常见的DOM属性之外，触摸事件还包括下列三个用于跟踪触摸的属性。
    * touches 表示跟踪的触摸操作的Touch对象的数组。
    * targetTouchs 特定于事件目标的Touch对象的数组。
    * changeTouches 表示自上次触摸以来发生了什么改变的Touch对象的数组。
    * clientX 触摸目标在视口中的x坐标。
    * clientY 触摸目标在视口中的y坐标。
    * identifier 表示触摸的唯一ID。
    * pageX 触摸目标在页面中的x坐标。
    * pageY 触摸目标在页面中的y坐标。
    * screenX 触摸目标在屏幕中的x坐标。
    * screenY 触摸目标在屏幕中的y坐标。
    * target 触摸的DOM节点目标。
  ```js
  function handleTouchEvent(event) {
      //只跟踪一次触摸
      if (event.touches.length == 1) {
          var output = document.getElementById("output");
          switch (event.type) {
              case "touchstart":
                  output.innerHTML = "Touch started (" + event.touches[0].clientX +
                      "," + event.touches[0].clientY + ")";
                  break;
              case "touchend":
                  output.innerHTML += "<br>Touch ended (" +
                      event.changedTouches[0].clientX + "," +
                      event.changedTouches[0].clientY + ")";
                  break;
              case "touchmove":
                  event.preventDefault(); //阻止滚动
                  output.innerHTML += "<br>Touch moved (" +
                      event.changedTouches[0].clientX + "," +
                      event.changedTouches[0].clientY + ")";
                  break;
          }
      }
  }
  EventUtil.addHandler(document, "touchstart", handleTouchEvent);
  EventUtil.addHandler(document, "touchend", handleTouchEvent);
  EventUtil.addHandler(document, "touchmove", handleTouchEvent);
  ```

  * #### 手势事件
   * gesturestart:当一个手指已经按在屏幕上而另一个手指又触摸屏幕时触发;
   * gesturechange:当触摸屏幕的任何一个手指的位置发生变化时触发;
   * gestureend:当任何一个手指从屏幕上面移开时触发。
  使用手势事件的一个实例:
  ```js
  function handleGestureEvent(event) {
      var output = document.getElementById("output");
      switch (event.type) {
          case "gesturestart":
              output.innerHTML = "Gesture started (rotation=" + event.rotation +
                  ",scale=" + event.scale + ")";
              break;
          case "gestureend":
              output.innerHTML += "<br>Gesture ended (rotation=" + event.rotation +
                  ",scale=" + event.scale + ")";
              break;
          case "gesturechange":
              output.innerHTML += "<br>Gesture changed (rotation=" + event.rotation +
                  ",scale=" + event.scale + ")";
              break;
      }
  }
  document.addEventListener("gesturestart", handleGestureEvent, false);
  document.addEventListener("gestureend", handleGestureEvent, false);
  document.addEventListener("gesturechange", handleGestureEvent, false);
  ```
