---
title: 表单脚本
---

## 表单的基础知识
表单对应的则是 HTMLFormElement 类型。 HTMLFormElement 继承了 HTMLElement，因而与其他 HTML 元素具有相同的默认属 性。不过， HTMLFormElement 也有它自己下列独有的属性和方法。

  * acceptCharset：服务器能够处理的字符集；等价于 HTML 中的 accept-charset 特性。
  * action：接受请求的 URL；等价于 HTML 中的 action 特性。
  * elements：表单中所有控件的集合（HTMLCollection）。
  * enctype：请求的编码类型；等价于 HTML 中的 enctype 特性。
  * length：表单中控件的数量。
  * method：要发送的 HTTP 请求类型，通常是"get"或"post"；等价于 HTML 的 method 特性。
  * name：表单的名称；等价于 HTML 的 name 特性。
  * reset()：将所有表单域重置为默认值。
  * submit()：提交表单。
  * target：用于发送请求和接收响应的窗口名称；等价于 HTML 的 target 特性。

通过 document.forms 可以取得页面中所有的表单。在这个集合中，可以通过数值索引或 name 值来取得特定的表单，如下面的例子所示。
```js
  var firstForm = document.forms[0]; //取得页面中的第一个表单
  var myForm = document.forms["form2"]; //取得页面中名称为"form2"的表单
```

## 提交表单
用户单击提交按钮或图像按钮时，就会提交表单。使用<input>或<button>都可以定义提交按钮， 只要将其 type 特性的值设置为"submit"即可，而图像按钮则是通过将<input>的 type 特性值设置为 "image"来定义的。因此，只要我们单击以下代码生成的按钮，就可以提交表单。
```html
<!-- 通用提交按钮 -->
<input type="submit" value="Submit Form">
<!-- 自定义提交按钮 -->
<button type="submit">Submit Form</button>
<!-- 图像按钮 -->
<input type="image" src="graphic.gif">
```
以这种方式提交表单时，浏览器会在将请求发送给服务器之前触发 submit 事件。这样，我们就有 机会验证表单数据，并据以决定是否允许表单提交。阻止这个事件的默认行为就可以取消表单提交。例 如，下列代码会阻止表单提交。
```js
var form = document.getElementById("myForm");
EventUtil.addHandler(form, "submit", function(event) {
    //取得事件对象
    event = EventUtil.getEvent(event);
    //阻止默认事件
    EventUtil.preventDefault(event);
});
```
提交表单时可能出现的最大问题，就是重复提交表单。解决这一问题 的办法有两个：在第一次提交表单后就禁用提交按钮，或者利用 onsubmit 事件处理程序取消后续的 表单提交操作。

## 重置表单
在用户单击重置按钮时，表单会被重置。使用 type 特性值为"reset"的<input>或<button>都 可以创建重置按钮，如下面的例子所示。
```html
<!-- 通用重置按钮 -->
<input type="reset" value="Reset Form">
<!-- 自定义重置按钮 -->
<button type="reset">Reset Form</button>
```
用户单击重置按钮重置表单时，会触发 reset 事件。利用这个机会，我们可以在必要时取消重置 操作。例如，下面展示了阻止重置表单的代码。
```js
var form = document.getElementById("myForm");
EventUtil.addHandler(form, "reset", function(event) {
    //取得事件对象
    event = EventUtil.getEvent(event);
    //阻止表单重置
    EventUtil.preventDefault(event);
});
与提交表单一样， 也可以通过 JavaScript 来重置表单， 如下面的例子所示。
var form = document.getElementById("myForm");
//重置表单
form.reset();
```

## 表单字段
除了fieldset元素之外,所有的表单字段都用相同的一组属性。
* disabled 表示当前字段是否被禁用。
* form 指向当前字段所属表单的指针。
* name 当前字段的名称。
* readOnly 表示当前字段是否只读。
* tabIndex 表示当前字段的切换序号
* type 当前字段的类型，列如"checkbox"、"radio"，等等+
* value 当前字段将被提交给服务器的值。

防止重复提交的解决方案，侦听submit事件，并在该事件发生时禁止提交按钮即可。
```js
  EventUtil.addHandler(form,"submit",function(event) {
    event = EventUtil.getEvent(event);
    var target = EventUtil.getTarget(event);
    // 取得提交按钮
    var btn = target.elements["submit-btn"];
   // 禁用它
    btn.disabled = true;
  })
```
不能通过onclick事件处理程序来实现这个功能，原因是引用不同浏览器之间存在"时差":有的浏览器会在出发表达的submit事件之前出发click事件，而又得浏览器相反。

type属性值:select-one select-multiple submit button reset submit。

此外，input和button元素的type属性是可以动态修改的，而select元素的type属性则是只读的。

### 共有的表单字段方法
每个表单字段都有两个方法:focus()和blur()。其中，focus()方法用于将浏览器的设置到表单字段，即激活表单字段，使其可以响应键盘事件。

HTML5为表单字段新增了一个autofocus属性。

### 共有的表单字段事件
除了支持鼠标、键盘、更改和HTML事件之外，所有表单字段都支持下列3个事件。
* blur 当前字段失去焦点时触发
* change 对于input和texttarea元素，在它们失去焦点且value值改变时触发;对于select元素，在其选项改变时触发。
* focus 当前字段获得焦点时触发。

### 文本框脚本
在HTML中，有两种方式来表现文本框:一种是使用input元素的单行文本框，另一种是使用textarea的多行文本框。要表现文本框，必须将input元素的type特性设置为text。而通过设置size特性，可以指定文本框中能够显示的字符数。通过value特性，可以设置文本框的初始值，而maxlength特性则用于指定文本框可以接受的最大字符数。设置textarea的大小可以使用rows和cols特性。在处理文本框时，最好不要使用DOM方法。直接设置value

### 选择文本
上述两种文本框都支持select方法，这个方法用于选择文本框中所有的文本。在调用select()方法时，大多数浏览器都会将焦点设置到文本框中。这个方法不接受参数。
```js
EventUtil.addHandler(textbook,"focus",function(event){
  event = EventUtil.getEvent(event);
  var target = EventUtil.getTarget(event);
  target.select();
})
```

1. 选择事件
与 select()方法对应的，是一个 select 事件。在选择了文本框中的文本时，就会触发 select 事件。不过，到底什么时候触发 select 事件，还会因浏览器而异。在 IE9+、 Opera、 Firefox、 Chrome 和 Safari 中，只有用户选择了文本（而且要释放鼠标），才会触发 select 事件。

2. 取得选择的文本
虽然通过 select 事件我们可以知道用户什么时候选择了文本，但仍然不知道用户选择了什么文本。 HTML5 通过一些扩展方案解决了这个问题，以便更顺利地取得选择的文本。该规范采取的办法是添加 两个属性： selectionStart 和 selectionEnd。这两个属性中保存的是基于 0 的数值，表示所选择 文本的范围（即文本选区开头和结尾的偏移量）。因此，要取得用户在文本框中选择的文本，可以使用 如下代码。

```js
function getSelectedText(textbox){
  return textbox.value.substring(textbox.selectionStart, textbox.selectionEnd);
}
```

3.过滤输入
屏蔽字符，列如电话号码中不能包含非数值字符。
```js
EventUtil.addHandler(textbox, "keypress", function(event) {
    event = EventUtil.getEvent(event);
    var target = EventUtil.getTarget(event);
    var charCode = EventUtil.getCharCode(event);
    if (!/\d/.test(String.fromCharCode(charCode))) {
        EventUtil.preventDefault(event);
    }
});
```

操作剪贴板，HTML5把剪贴板事件纳入了规范。下列就是6个剪贴板事件。
* beforecopy 在发生复制操作之前出发。
* copy 在发生复制操作时触发。
* beforecut 在发生剪切操作前触发。
* cut 在发生剪切操作时触发。
* beforepaste 在发生粘贴操作时触发
* paste 在发生粘贴操作时触发。

为了确保兼容性，可以使用clipboardData对象，这个对象有三个方法:getData()、setData()和clearData()。getData接收一个参数，即要取得的数据格式。有两种数据格式:"text"和"URL"。这个参数是一种MIME类型;
不过，可以用"text"代表"text/plain"。
```js
var EventUtil = {
    //省略的代码
    getClipboardText: function(event) {
        var clipboardData = (event.clipboardData || window.clipboardData);
        return clipboardData.getData("text");
    },
    //省略的代码
    setClipboardText: function(event, value) {
        if (event.clipboardData) {
            return event.clipboardData.setData("text/plain", value);
        } else if (window.clipboardData) {
            return window.clipboardData.setData("text", value);
        }
    },
    //省略的代码
};
```

自动焦点切换
```js
(function(){
	function tabForward(event){
		event = EventUtil.getEvent(event);
		var target = EventUtil.getTarget(event);
		if (target.value.length == target.maxLength){
			var form = target.form;
			for (var i=0, len=form.elements.length; i < len; i++) {
				if (form.elements[i] == target) {
					if (form.elements[i+1]){
						form.elements[i+1].focus();
					}
					return;
				}
			}
		}
	}
	var textbox1 = document.getElementById("txtTel1");
	var textbox2 = document.getElementById("txtTel2");
	var textbox3 = document.getElementById("txtTel3");
	EventUtil.addHandler(textbox1, "keyup", tabForward);
	EventUtil.addHandler(textbox2, "keyup", tabForward);
	EventUtil.addHandler(textbox3, "keyup", tabForward);
})();
```

HTML5约束验证API
为了再将表单提交到服务器之前验证数据，HTML5新增了一些功能。有了这些功能，即便 JavaScript 被禁用或者由于种种原因未能加载，也可以确保基本的验证。换句话说，浏览器自己会根据标记中的规则执行验证，然后自己显示适当的错误消息（完全不用 JavaScript 插手）。

1. 必填字段
第一种情况实在表单字段中指定了required属性，如下:
```html
<input type="text" name="username" required>
```
任何标有required的字段，在提交表单时都不能空着。这个属性适用于input、textarea和select字段。

2. 其他输入类型
```html
<input type="email">
<input type="url">
```

3. 输入模式
HTML5为文本字段新增加了pattern属性。这个属性的值是一个正则表达式，用于匹配文本框中的值。
```html
<input type="text" pattern="\d">
```
注意，模式的开头和末尾不用加^和$。

4. 检测有效性
使用checkValidity()方法可以检测表单中的某个字段是否有效。所有表单都有个方法，如果字段的值有效，这个方法返回true否则返回false。

5. 禁用验证
通过设置novalidate属性可以告诉表单不进行验证。

## 选择框脚本
选择框是通过<select>和<option>元素创建的。HTMLSelectElement 类型还提供了下列属性和方法:
* add(newOption, relOption)：向控件中插入新<option>元素，其位置在相关项（relOption） 之前。
* options：控件中所有<option>元素的 HTMLCollection。
* remove(index)：移除给定位置的选项。
* options：控件中所有<option>元素的 HTMLCollection。
* selectedIndex：基于 0 的选中项的索引，如果没有选中项，则值为-1。对于支持多选的控件， 只保存选中项中第一项的索引。
* size：选择框中可见的行数；等价于 HTML 中的 size 特性。

选择框的 type 属性不是"select-one"，就是"select-multiple"，这取决于 HTML 代码中有 没有 multiple 特性。

在 DOM 中，每个<option>元素都有一个 HTMLOptionElement 对象表示。为便于访问数据， HTMLOptionElement 对象添加了下列属性：
* index：当前选项在 options 集合中的索引。
* label：当前选项的标签；等价于 HTML 中的 label 特性。
* selected：布尔值，表示当前选项是否被选中。将这个属性设置为 true 可以选中当前选项。
* text：选项的文本。
* value：选项的值（等价于 HTML 中的 value 特性）。

## 表单序列化
浏览器是怎样将数据发送给服务器的:

* 对表单字段的名称和值进行 URL 编码，使用和号（&）分隔。
* 不发送禁用的表单字段。
* 只发送勾选的复选框和单选按钮
* 不发送 type 为"reset"和"button"的按钮。
* 多选选择框中的每个选中的值单独一个条目。
* 在单击提交按钮提交表单的情况下，也会发送提交按钮；否则，不发送提交按钮。也包括 type 为"image"的<input>元素。
* <select>元素的值，就是选中的<option>元素的 value 特性的值。如果<option>元素没有 value 特性，则是<option>元素的文本值。
```js
function serialize(form) {
	var parts = [],
		field = null,
		i,
		len,
		j,
		optLen,
		option,
		optValue;
	for (i = 0, len = form.elements.length; i < len; i++) {
		field = form.elements[i];
		switch (field.type) {
			case "select-one":
			case "select-multiple":
				if (field.name.length) {
					for (j = 0, optLen = field.options.length; j < optLen; j++) {
						option = field.options[j];
						if (option.selected) {
							optValue = "";
							if (option.hasAttribute) {
								optValue = (option.hasAttribute("value") ?
									option.value : option.text);
							} else {
								optValue = (option.attributes["value"].specified ?
									option.value : option.text);
							}
							parts.push(encodeURIComponent(field.name) + "=" +
								encodeURIComponent(optValue));
						}
					}
				}
				break;
			case undefined: //字段集
			case "file": //文件输入
			case "submit": //提交按钮
			case "reset": //重置按钮
			case "button": //自定义按钮
				break;
			case "radio": //单选按钮
			case "checkbox": //复选框
				if (!field.checked) {
					break;
				}
			/* 执行默认操作 */
			default:
//不包含没有名字的表单字段
				if (field.name.length) {
					parts.push(encodeURIComponent(field.name) + "=" +
						encodeURIComponent(field.value));
				}
		}
	}
	return parts.join("&");
}
}
```

## 富文本编辑
富文本编辑，又称为 WYSIWYG（What You See Is What You Get，所见即所得）。在网页中编辑富 文本内容，是人们对 Web 应用程序最大的期待之一。 这一技术 的本质，就是在页面中嵌入一个包含HTML 页面的 iframe。通过设置 designMode 属性，这个空白 的 HTML 页面可以被编辑，而编辑对象则是该页面<body>元素的 HTML 代码。 designMode 属性有两 个可能的值： "off"（默认值）和"on"。在设置为"on"时，整个文档都会变得可以编辑（显示插入符 号），然后就可以像使用字处理软件一样，通过键盘将文本内容加粗、变成斜体，等等
```html
<iframe name="richedit" style="height:100px;width:100px;" src="blank.htm"></iframe>
<script type="text/javascript">
EventUtil.addHandler(window, "load", function(){
frames["richedit"].document.designMode = "on";
});
</script>
```
另一种编辑富文本内容的方式是使用名为 contenteditable 的特殊属性，这个属性也是由 IE 最 早实现的。可以把 contenteditable 属性应用给页面中的任何元素，然后用户立即就可以编辑该元素。
这种方法之所以受到欢迎，是因为它不需要 iframe、空白页和 JavaScript，只要为元素设置
contenteditable 属性即可。

``` js
var div = document.getElementById("richedit");
div.contentEditable = "true";
```

### 操作富文本
与富文本编辑器交互的主要方式，就是使用 document.execCommand()。这个方法可以对文档执 行预定义的命令，而且可以应用大多数格式。可以为 document.execCommand()方法传递 3 个参数： 要执行的命令名称、表示浏览器是否应该为当前命令提供用户界面的一个布尔值和执行命令必须的一个
值（如果不需要值，则传递 null）。

### 表单与富文本
由于富文本编辑是使用 iframe 而非表单控件实现的，因此从技术上说，富文本编辑器并不属于表 单。换句话说，富文本编辑器中的 HTML 不会被自动提交给服务器，而需要我们手工来提取并提交 HTML。为此，通常可以添加一个隐藏的表单字段，让它的值等于从 iframe 中提取出的 HTML。具体 来说，就是在提交表单之前，从 iframe 中提取出 HTML，并将其插入到隐藏的字段中。下面就是通过 表单的 onsubmit 事件处理程序实现上述操作的代码。

```js
EventUtil.addHandler(form, "submit", function(event){
event = EventUtil.getEvent(event);
var target = EventUtil.getTarget(event);
target.elements["comments"].value = frames["richedit"].document.body.innerHTML;
});
```