---
title: 事件
---
JavaScript与HTML的交互式通过事件实现的。事件，就是文档或浏览器窗口发生的一些特定的交互瞬间。可以使用侦听器(或处理程序)来预定事件

## 事件流
如同在一张纸上画一组同心圆，如果把手指放在圆心上，那么手指指向的就不是一个圆，而是纸上所有圆。事件流描述的是从页面中接收事件的顺序。IE的事件流是事件冒泡，儿Netscape的事件流是事件捕获。

  * ### 事件冒泡
  IE的事件流叫做事件冒泡，即事件开始由最具体的元素(文档中嵌套层次最深的那个节点)接收，然后逐级向上传播到较为不具体的节点(文档)。所有现代浏览器都支持事件冒泡，但实现上还是有一些差别。

  * ### 事件捕获
  事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于咋事件到达预定目标之前捕获它。尽管"DOM2级事件"规范要求事件应该从document对象开始传播，但这些浏览器都是从window对象开始捕获事件的。建议使用事件冒泡。

  * ### DOM事件流
  "DOM2级事件"规定的事件流包括三个阶段:事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件作出响应。

## 事件处理程序
事件就是用户或浏览器自身执行的某种动作。而响应某个事件的函数就叫做事件处理程序(或事件侦听器)。事件处理程序的名字以"on"开头，

  * ### HTML事件处理程序
  某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定。这个特性的值应该是能够执行的JavaScript代码。在HTML中定义的事件处理程序可以包含要执行的具体动作，也可以调用在页面其他地方定义的脚本。这样指定事件处理程序可以创建一个封装着元素属性的函数。这个函数中有一个局部变量event，也就就是事件对象。通过它可以直接访问事件对象，你不用自己定义它，在函数内部，this值等于事件的目标元素。

  * ### DOM0级事件处理程序
  通过JavaScript指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。要使用该事件处理程序，首先必须取得一个要操作的对象的引用。每个元素(包括window和document)都有自己的事件处理程序属性，这些属性通常全部要小写，将这种属性的值设置为一个函数就可以指定事件处理程序:
  ```js
    var btn = document.getElementById("myBtn");
    btn.onclick = function(){
      alert("a");
    }
  ```
  在此我们通过文档对象取得了一个按钮的引用，然后为它指定了onclick事件处理程序。可以通过`btn.onclick = null`删除DOM0级方法指定的事件处理程序。

  * ### DOM2级事件处理程序
  定义了两个方法，用于处理指定和删除事件处理程序的操作:addEventLisenter()和removeEventListener()。所有DOM节点中都包含着两个方法，并且他们都包含三个参数:要处理的事件名，作为事件处理程序的函数和一个布尔值。最后这个参数如果是true，表示在捕获阶段调用事件处理程序。如果是false，表示在冒泡阶段调用事件处理程序。使用DOM2级方法添加事件处理程序的主要好处是可以添加多个事件处理程序。
  ```js
    var btn = document.getElementById("myBtn");
    btn.addEventListenter("click",function(){
      alert(this.id);
    },false);
    btn.addEventListenter("click",function(){
      alert("hello world");
    },false);
  ```
  这里为按钮添加了两个事件处理程序。这两个事件处理程序会按照添加他们的顺序触发。通过使用removeEventListener()来移除添加的事件处理程序;移除时传入的参数与添加处理程序时使用的参数相同。
  ```js
  var btn = document.getElementById("myBtn");
  btn.addEventListenter("click",function(){
    alert(this.id);
  },false);
  btn.removeEventListener("click",function(){//无法移除匿名函数
    alert(this.id);
  },false);
  //可以通过函数表达式来实现
  var handler = function(){
    alert(this.id);
  }
  btn.addEventListener("click",handler,false);
  btn.removeEventListener("click",handler,false);
  ```
  大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需要，我们不建议在事件捕获阶段注册事件处理程序。

  * ### IE事件处理程序
  IE实现了与DOM中类似的两个方法:attachEvent()和detachEvent()。这两个方法接受两个参数:事件处理程序名称与事件处理程序函数。
  ```js
  var btn = document.getElementById("myBtn");
  btn.attachEvent("onclick",function(){
    alert(this.id);
  },false);
  ```
  注意在attachEvent()的第一个参数是"onclick";而非DOM的addEventListenter()方法中的"click"。如果调用两次attachEvent()，会以与添加顺序相反的顺序被触发。

  * ### 跨浏览器的事件处理程序
  为了以跨浏览器的方式处理事件，可以恰当地使用能力检测。第一个要创建的方法是addHandler()，它的职责是视情况分别使用DOM0级方法、DOM2级方法或IE方法来添加事件。这个方法属于一个名叫EventUtil的对象。
  ```js
  var EventUtil = {
      addHandler: function(element, type, handler) {
          if (element.addEventListener) {
              element.addEventListener(type, handler, false);
          } else if (element.attachEvent) {
              element.attachEvent("on" + type, handler);
          } else {
              element["on" + type] = handler;
          }
      },
      removeHandler: function(element, type, handler) {
          if (element.removeEventListener) {
              element.removeEventListener(type, handler, false);
          } else if (element.detachEvent) {
              element.detachEvent("on" + type, handler);
          } else {
              element["on" + type] = null;
          }
      }
  };
  ```
## 事件对象
在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如，鼠标操作导致的事件对象中，会包含鼠标位置的信息，而键盘操作导致的事件对象中，会包含与按下键有关的信息。所有浏览器都支持event但支持方式不同。

  * ### DOM中的事件对象
  兼容DOM的浏览器会将一个event对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法(DOM0级或DOM2级)，都会传入event对象。
    * bubbles 是否冒泡
    * cancelable 是否可以取消事件的默认行为
    * currentTarget 其事件处理程序当前正在处理事件的元素
    * defaultPrevent true表示已经调用了preventDefault()(DOM3级事件中新增)
    * detail 与事件相关的细节信息
    * eventPhase 调用事件处理程序的阶段:1表示捕获阶段2表示处于目标3表示冒泡阶段
    * preventDefault() 取消事件的默认行为。
    * stopImmediatePropagation() 取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用(DOM3级事件中新增)
    * stopPropagation() 取消事件的进一步捕获或冒泡。
    * target 事件的目标
    * trusted 为true表示事件是浏览器生成的。为false表示事件是由开发人员通过JavaScript创建的(DOM3级事件新增)
    * type 被触发的事件的类型
    * view 与事件关联的抽象视图。等同于发生事件的window对象
  如果需要通过一个函数处理多个事件时，可以使用type属性。例如:
  ```js
    var btn = document.getElementById("myBtn");
    var handler = function(event){
      switch(event.type){
        case "click":
          alert("clicked");
          break;
        case "mouseover":
          alert("mouseover");
          break;
        case "mouseout":
          alert("mouseout");
          break;
      }
    };
    btn.onclick = handler;
    btn.onmouseover = handler;
    btn.onmouseout = handler;
  ```
  可以使用preventDefault()方法阻止默认行为:
  ```js
    var link = document.getElementById("myLink");
    link.onclick = function(){
      event.preventDefault();
    }
  ```
  可以使用stopPropagation()取消进一步的事件捕获或冒泡。
  ```js
    var btn = document.getElementById("myBtn");
    btn.onclick =  function(event){
      alert("clicked");
      event.stopPropagation();
    }
    document.body.onclick = function(event){
      alert("body clicked");
    }
  ```
  只有在事件处理程序执行期间，event对象才会存在;一旦事件处理程序执行完成，event对象就会被销毁。

  * ### IE中的事件对象
  如果是通过HTML特性指定的事件处理程序，可以用一个名叫event的变量来访问event对象。
    * cancelBubble 设置为true就可以取消事件冒泡
    * returnValue 将其设置为false就可以取消事件的默认行为
    * srcElement 事件的目标
    * type 被处罚的事件类型
  因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为this会始终等于事件目标。故而，最好还是使用event.srcElement比较保险。
  ```js
    var btn = document.getElementById("myBtn");
    btn.onclick =  function(event){
      alert(window.event.srcElement === this)//true
    };
    btn.attachEvent("onclick",function(event){
      alert(window.event.srcElement === this)//true
    });
  ```
  设置cancelBubble为true则可以取消事件冒泡:
  ```js
  var btn = document.getElementById("myBtn");
  btn.onclick =  function(event){
    alert("clicked");
    window.event.cancelBubble = true;
  }
  document.body.onclick = function(event){
    alert("body clicked");
  }
  ```

  * ### 跨浏览器的事件对象
  ```js
  var EventUtil = {
      addHandler: function(element, type, handler) {
          //省略的代码
      },
      getEvent: function(event) {
          return event ? event : window.event;
      },
      getTarget: function(event) {
          return event.target || event.srcElement;
      },
      preventDefault: function(event) {
          if (event.preventDefault) {
              event.preventDefault();
          } else {
              event.returnValue = false;
          }
      },
      removeHandler: function(element, type, handler) {
          //省略的代码
      },
      stopPropagation: function(event) {
          if (event.stopPropagation) {
              event.stopPropagation();
          } else {
              event.cancelBubble = true;
          }
      }
  };
  ```

## 事件类型
DOM3级事件规定了以下几类事件:
 * UI事件，当用户与页面上的元素交互时触发;
 * 焦点事件，当元素获得或失去焦点时触发;
 * 鼠标事件，当用户通过鼠标在页面上执行操作时触发;
 * 滚轮事件，当使用鼠标滚轮是触发;
 * 文本事件，当在文档中输入文本是触发;
 * 键盘事件，当用户通过键盘在页面上执行操作时触发;
 * 合成事件，当IME(Input Method Editor，输入法编辑器)输入字符时触发;
 * 变动(mutation)事件，当底层DOM结构发生变化时触发。
 * 变动名称事件，当元素或属性名变动时触发。此类事件已经被废弃。
除了这几类事件之外，HTML5页定义了一组事件，而有些浏览器还会在DOM和BOM中实现其他专有事件。

 * ### UI事件
 UI事件指的是那些不一定与用户操作有关的事件。
  * load:当页面完全加载后再window上触发
  ```js
    // <img src="" onload="alert("a")"/> 为图像添加load事件

  ```
  * unload:当页面完全卸载后再window上面触发，用户从一个页面切换到另一个页面，就会发生unload事件。而利用这个事件最多的情况就是清除引用，以免内存泄漏。
  * abort:当用户停止下载过程时
  * error:当发生JavaScript错误时在window上面触发



  * resize:当窗口或框架的大小发生变化时，浏览器窗口最小或最大化时也会触发resize事件。
  * scroll:当用户滚动带滚动条的元素中的内容时，在该元素上面触发。

* ### 焦点事件
document.hasFocus()方法及document.activeElement属性配合可以知晓用户在页面上的行踪。有以下6个焦点事件。
 * blur 在元素失去焦点时触发。这个事件不会冒泡;所有浏览器都支持它。
 * focus 在元素获得焦点时触发。这个事件不会冒泡;所有浏览器都支持它。
 * focusin 在元素获得焦点时触发。这个事件与HTML事件focus等价，但会冒泡;
 * focusout 在元素失去焦点时触发。这个事件是HTML事件blur的通用版。

* ### 鼠标和滚轮事件
DOM3级事件中定义了9个鼠标事件:
 * click:在用户单击鼠标主鼠标按钮(一般是左边的按钮)或者按下回车键时触发。这一点对确保易访问性很重要，意味着onclick事件处理程序既可以通过键盘也可以通过鼠标执行。
 * dbclick:双击时触发。
 * mousedown:在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件。
 * mouseenter:在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。
 * mouseleave:在位于元素上方的鼠标移动到元素范围之外时触发。这事件不会冒泡。
 * mousemove:当鼠标指针在元素内部移动时重复触发。不能通过键盘触发这个事件。
 * mouseout:在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。
 * mouseover:在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发。
 * mouseup:用户在释放鼠标按钮时触发，不能通过键盘触发。
页面上所有元素都支持鼠标事件。除了mouseenter和mouseleave，所有鼠标事件都会冒泡，也可以被取消，而取消鼠标事件将影响浏览器的默认行为。取消鼠标事件的默认行为会影响其他事件。只有在同一个元素上相继触发mousedown和mouseup事件，才会触发click事件;如果mousedown或mouseup中的一个被取消，就不会触发click事件。
鼠标事件都是在浏览器视口中的特定位置上发生的。这个位置信息保存在事件对象的clientX和clientY属性中。所有浏览器都支持这两个属性，它们的值表示事件发生时鼠标指针在视口中的水平位置和垂直位置。
```js
  var div = document.getElementById("myDiv");
  EventUtil.addHandler(div,"click",function(event){
    event = EventUtil.getEvent(event);
    alert("Client coordinates:"+event.clientX+","+event.clientY);
  })
```
通过pageX和pageY属性可以告诉你事件是在页面中声明位置发生的。这两个属性表示鼠标光标在页面中的位置。因此左边是从页面本身而非视口的左边和定边计算的。在页面没有滚动的情况下pageX和pageY的值与clientX和clientY的值相等。
```js
  var div = document.getElementById("myDiv");
  EventUtil.addHandler(div,"click",function(event){
    event = EventUtil.getEvent(event);
    var pageX = event.pageX;
    var pageY = event.pageY;
    if(pageX === undefined){
      pageX = event.clientX + (document.body.scrollLeft || document.documentElement.scrollLeft);
    }
    if(pageY === undefined){
      pageY = event.clientY + (document.body.scrollTop || document.documentElement.scrollTop);
    }
    alert("page coordinates:" + pageX + "," + pageY);
  });
```
屏幕坐标位置:鼠标事件发生时，不仅会有相对于浏览器窗口的位置，还有一个相对于整个电脑屏幕的位置。而通过screenX和screenY属性就可以确定鼠标事件发生时鼠标指针相对于整个屏幕的坐标信息。使用下面的代码取得鼠标事件的屏幕坐标:
```js
var div = document.getElementById("myDiv");
EventUtil.addHandler(div,"click",function(event){
  event = EventUtil.getEvent(event);
  alert("Client coordinates:"+event.screenX+","+event.screenY);
})
```
修改键:DOM规定了4个属性表示这些修改键的状态:shiftKey、ctrlKey、altKey和metaKey。
```js
var div = document.getElementById("myDiv");
EventUtil.addHandler(div, "click", function(event) {
    event = EventUtil.getEvent(event);
    var keys = new Array();
    if (event.shiftKey) {
        keys.push("shift");
    }
    if (event.ctrlKey) {
        keys.push("ctrl");
    }
    if (event.altKey) {
        keys.push("alt");
    }
    if (event.metaKey) {
        keys.push("meta");
    }
    alert("Keys: " + keys.join(","));
});
```
相关元素:DOM通过event对象的relatedTarget属性提供了相关元素的信息。这个属性只对于mouseover和mouseout事件才包含值;对于其他事件，这个属性的值是null。鼠标按钮:DOM的button属性可能有如下3个值:0表示主鼠标按钮，1表示中间的鼠标按钮(鼠标滚轮按钮)，2表示次鼠标按钮。

* ### 更多的事件信息
detail属性给出有关事件的更多信息。其保护了一个数值，表示在给定位置上发生了多少次单击。detail属性从1开始计数，每次单击发生后都会递增。如果鼠标在mousedown和mouseup之间移动了位置，则detail被重置为0。
 * altLeft:表示是否按下了Alt键。
 * ctrlLeft:表示是否按下了Ctrl键。
 * offsetX:光标相对于目标元素边界的x坐标。
 * offsetY:光标相对于目标元素边界的y坐标。
 * shiftLeft:表示是否按下了Shift键。
 只有IE支持他们

* ### 鼠标滚轮事件
当用户通过鼠标滚轮与页面交互，在垂直方向上滚动页面时，就会触发mousewheel事件。这个事件可以在任何元素上面触发，最终会冒泡到document或window对象。与mousewheel事件对于的event对象除包含鼠标事件的所有标准信息外，还包含一个特殊的wheelDelta属性。当用户向前滚动鼠标滚轮时，wheelDelta是120的倍数;当用户向后滚动滚轮时，wheelDelta是-120的倍数。DOMMouseScroll是Firefox支持的类似事件。

## 键盘与文本事件
DOM3级事件为键盘事件制定了规范:
  * keydown 当用户按下键盘时触发，而且如果按住不放的话，会重复触发此事件。
  * keypress 当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件。按下Esc键也会触发这个事件。
  * keyup 当用户释放键盘上的键时触发。
  只有一个文本事件:textInput。这个事件是对keypress的补充。用意是将文本显示给用户之前更容易拦截文本。主要考虑的是字符，因此它的event对象中还包含一个data属性，这个属性值就是用户输入的字符。
```js
  var textbox = documen.getElementById("myText");
  EventUtil.addHandler(textbox,"textInput",function(event){
    event = EventUtil.getEvent(event);
    alert(event.data);
  })
```
event对象上还有一个属性，叫inoutMethod:
 * 0 表示浏览器不确定是怎么输入的。
 * 1 表示是使用键盘输入的。
 * 2 表示文本是粘贴进来的。
 * 3 表示是拖放进来的。
 * 4 表示文本是使用IME输入的。
 * 5 表示文本是通过在表单中选择某一项输入的。
 * 6 表示文本是通过手写输入的(比如使用手写笔)。
 * 7 表示文本是通过语音输入的。
 * 8 表示文本是通过几种方法组合输入的。
 * 9 表示文本是通过脚本输入的。

## 复合事件
有以下三种复合事件:
 * compositionstart:在IME的文本复合系统打开是触发，表示开始要输入。
 * compositionupdate:在向输入字段中插入新字符时触发。
 * compositionedn:表示返回正常的键盘输入状态。

## 变动事件
DOM2级定义了如下变动事件:
 * DOMSubtreeModified:在DOM结构中发生任何变化时触发。这个事件在其他任何事件触发后都会触发。
 * DOMNodeInserted:在一个节点作为子节点被插入到另一个节点时触发。
 * DOMNodeRemoved:在节点ongoing其父节点中被移除时触发。
 * DOMNodeInsertedIntoDocument:在一个节点被直接从文档中移除或通过子树间接从插入文档之后触发。这个事件在DOMNodeInserted之后触发。
 * DOMNodeRemovedFromDocument:在一个节点被直接从文档中移除或通过子树间接从文档中移除之前触发。这个事件在DOMNodeRemoved之后触发。
 * DOMAttrModified:在特性被修改之后触发。
 * DOMCharaterDataModified:在文本节点的值发生变化时触发。
使用`var isSupport = document.implementation.hasFeature("MutationEvents","2.0")`检测浏览器是否支持变动事件。

## HTML5事件
  * ### contextmenu事件
  上下文菜单事件，是冒泡的，因此可以为document指定一个事件处理程序，用以处理页面中发生的所有此类事件。
```js
EventUtil.addHandler(window, "load", function(event) {
    var div = document.getElementById("myDiv");
    EventUtil.addHandler(div, "contextmenu", function(event) {
        event = EventUtil.getEvent(event);
        EventUtil.preventDefault(event);
        var menu = document.getElementById("myMenu");
        menu.style.left = event.clientX + "px";
        menu.style.top = event.clientY + "px";
        menu.style.visibility = "visible";
    });
    EventUtil.addHandler(document, "click", function(event) {
        document.getElementById("myMenu").style.visibility = "hidden";
    });
});
```

* ### beforeunloa事件
之所以有此类事件，是为了让开发人员有可能在页面卸载前阻止这一操作。这个事件会在浏览器卸载页面之前触发，可以通过它来取消卸载并继续使用原有的页面。
```js
EventUtil.addHandler(window, "beforeunload", function(event) {
    event = EventUtil.getEvent(event);
    var message = "I'm really going to miss you if you go.";
    event.returnValue = message;
    return message;
});
```

* ### DOMContentLoaded事件
如果使用window的load事件会在页面中的一切都加载完毕时触发，而DOMContentLoaded事件则在形成完整的DOM树之后就会触发，不例会图像，JavaScript文件等是否已经下载完毕。

* ### readystatechange事件
这个事件的目的是提供与文档或元素的加载状态有关的信息，支持该事件的每个对象都有一个readystate属性:
 * uninitialized(未初始化): 对象存在但尚未初始化。
 * loading(正在加载):对象正在加载数据。
 * loaded(加载完毕)
 * interactive(交互):可以操作对象了，但是还没有完全加载。
 * complete(完成):对象已经加载完毕。

* ### pageshow和pagehide事件
个别浏览器带有前进后退缓存，那么当前进和后退时就不会触发load事件，此时可以使用pageshow事件来解决load需求。
```js
  (function(){
    var showCount = 0;
    EventUtil.addHandler(window,"load",function(){
      alert("Load fired");
    })
    EventUtil.addHandler(window,"pageshow",function(){
      showCount++;
      alert("show has been fired" + showCount + "times");
    });
  })();
```

* ### hashchange事件
以便在URL的参数列表(及URL中"#"号侯曼的所有字符串)发生变化时通知开发人员。之所以增加这个事件，是因为在Ajax应用中，开发人员经常要利用URL参数列表来保存状态或导航信息。必须要把hashchange事件处理程序添加给window对象，然后URL参数列表只要变化就会调用它。此时的event对象应该额外包含两个属性:oldURL和newURL。由于浏览器支持情况各异，推荐使用location对象来确定当前的参数列表。
```js
EventUtil.addHandler(window,"hashchange",function(event){
  alert("Current hash:" + location.hash);
})
```

* ### 设备事件
设备事件(device event)可以让开发人员确定用户在怎样使用设备。
 * #### orientationchange事件
 window.orientation包含三个属性:0表示肖像模式，90表示向左旋转的横向模式("主屏幕"按钮在右侧)，-90表示向右旋转的横向模式("主屏幕"按钮在左侧)
 ```js
  EventUtil.addHandler(window,"load",function(event){
    var div = document.getElementById("myDiv");
    div.innerHTML = "current orientation is" + window.orientation;
    EventUtil.addHandler(window,"orientationchange",function(event){
      div.innerHTML = "current orientation is" + window.orientation;
    })
  })
 ```

 * #### MozOrientation事件
 Firefox为该事件设置了3个属性:x，y，和z。这几个属性的值都介于1到-1直接，表示不同坐标轴上的方向。在静止状态下，x值为0，y值为0，z的值为1(表示设备处于竖直状态)。如果设备向右倾斜，x值会减小;反之，向左倾斜，x值会增大。类似地，如果设备向远离用户的方向倾斜，y值会减小，向接近用户的方向倾斜y值会增大。z轴检测垂直加速度，1表示静止不动，在设备移动时值会减小。(失重状态下值为0)

 * #### deviceorientation事件
  * alpha 在围绕z轴旋转时(即左右旋转时)，y轴的度数差;是一个介于0到360之间的浮点数。
  * beta 在围绕x轴旋转时(即前后旋转时)，z轴的度数差;是一个介于-180到180之间的浮点数。
  * gamma 在围绕y轴旋转时(即扭转设备时)，z轴的度数差;是一个介于-90到90的之间的浮点数。
  * absolute 表示设备是否返回一个绝对值。
  * compassCalibrated 表示设备的指南针是否校准过。
  通过这些信息，可以响应设备的方向，重新排列或修改屏幕上的元素。要响应设备方向的改变而旋转元素可以参考如下代码:
  ```js
  EventUtil.addHandler(window, "deviceorientation", function(event){
    var arrow = document.getElementById("arrow");
    arrow.style.webkitTransform = "rotate(" + Math.round(event.alpha) + "deg)";
  });
  ```
  只能用于移动webkit浏览器中，因为他使用了专有的webkitTransform。

* #### devicemotion事件
DeviceOrientation Event规范定义了devicemotion事件。这个事件是要告诉开发人员设备什么时候移动，而不仅仅是设备方向如果改变。通过devicemotion能够坚持到设备是不是正在往下掉，或者是不是被走着的人拿在手里。
 * acceleration: 一个包含x、y和z属性的对象，在不考虑重力的情况下，告诉你在每个方向上的加速度。
 * accelerationIncludingGravity: 一个包含x、y和z的属性的对象，在考虑z轴自然重力加速度的情况下，告诉你在每个方向上的加速度。
 * interval: 以毫秒表示的时间值，必须在另一个devicemotion事件触发前传入。
 * rotationRate 一个包含表示方向的alpha、beta和gamma属性的对象。
 ```js
 EventUtil.addHandler(window, "devicemotion", function(event) {
     var output = document.getElementById("output");
     if (event.rotationRate !== null) {
         output.innerHTML += "Alpha=" + event.rotationRate.alpha + ", Beta=" +
             event.rotationRate.beta + ", Gamma=" +
             event.rotationRate.gamma;
     }
 });
 ```

* ### 触摸与手势事件
Touch Event规范
 * #### 触摸事件
 触摸事件会在用户手指放在屏幕上面时、在屏幕上滑动时或从屏幕上移开时触发。
  * touchstart 当手指触摸屏幕时触发;即使已经有一个手指放在了屏幕上也会触发。
  * touchmove 当手指在屏幕上滑动时连续地触发。在这个事件发生期间，调用preventDefault()可以阻止滚动。
  * touchend 当手指从屏幕上移开时触发。
  * touchcancel 当系统停止跟踪触摸时触发。
  上面几个事件都会冒泡，也都可以取消。虽然这些触摸事件没有在DOM规范中定义，但他们却是以兼容DOM的方式实现的。因此，每个触摸事件的event对象都提供了在鼠标事件中常见的属性:bubbles，cancelable，view，clientX，clientY，screenX，screenY，detail，altKey，shiftkey，ctrlKey，和metaKey。
  除了常见的DOM属性之外，触摸事件还包括下列三个用于跟踪触摸的属性。
    * touches 表示跟踪的触摸操作的Touch对象的数组。
    * targetTouchs 特定于事件目标的Touch对象的数组。
    * changeTouches 表示自上次触摸以来发生了什么改变的Touch对象的数组。
    * clientX 触摸目标在视口中的x坐标。
    * clientY 触摸目标在视口中的y坐标。
    * identifier 表示触摸的唯一ID。
    * pageX 触摸目标在页面中的x坐标。
    * pageY 触摸目标在页面中的y坐标。
    * screenX 触摸目标在屏幕中的x坐标。
    * screenY 触摸目标在屏幕中的y坐标。
    * target 触摸的DOM节点目标。
  ```js
  function handleTouchEvent(event) {
      //只跟踪一次触摸
      if (event.touches.length == 1) {
          var output = document.getElementById("output");
          switch (event.type) {
              case "touchstart":
                  output.innerHTML = "Touch started (" + event.touches[0].clientX +
                      "," + event.touches[0].clientY + ")";
                  break;
              case "touchend":
                  output.innerHTML += "<br>Touch ended (" +
                      event.changedTouches[0].clientX + "," +
                      event.changedTouches[0].clientY + ")";
                  break;
              case "touchmove":
                  event.preventDefault(); //阻止滚动
                  output.innerHTML += "<br>Touch moved (" +
                      event.changedTouches[0].clientX + "," +
                      event.changedTouches[0].clientY + ")";
                  break;
          }
      }
  }
  EventUtil.addHandler(document, "touchstart", handleTouchEvent);
  EventUtil.addHandler(document, "touchend", handleTouchEvent);
  EventUtil.addHandler(document, "touchmove", handleTouchEvent);
  ```

  * #### 手势事件
   * gesturestart:当一个手指已经按在屏幕上而另一个手指又触摸屏幕时触发;
   * gesturechange:当触摸屏幕的任何一个手指的位置发生变化时触发;
   * gestureend:当任何一个手指从屏幕上面移开时触发。
  使用手势事件的一个实例:
  ```js
  function handleGestureEvent(event) {
      var output = document.getElementById("output");
      switch (event.type) {
          case "gesturestart":
              output.innerHTML = "Gesture started (rotation=" + event.rotation +
                  ",scale=" + event.scale + ")";
              break;
          case "gestureend":
              output.innerHTML += "<br>Gesture ended (rotation=" + event.rotation +
                  ",scale=" + event.scale + ")";
              break;
          case "gesturechange":
              output.innerHTML += "<br>Gesture changed (rotation=" + event.rotation +
                  ",scale=" + event.scale + ")";
              break;
      }
  }
  document.addEventListener("gesturestart", handleGestureEvent, false);
  document.addEventListener("gestureend", handleGestureEvent, false);
  document.addEventListener("gesturechange", handleGestureEvent, false);
  ```

## 内存和性能
每个函数都是对象，都会占用内存;内存中的对象越多，性能就越差。
  * ### 事件委托
  对"事件处理程序过多"问题的解决方案就是事件委托。事件委托是利用了事件冒泡。只指定一个事件处理程序，就可以管理某一类型的所有事件。使用事件委托，只需要在DOM树中尽量最高的层次添加一个事件处理程序。
  ```js
  var list = document.getElementById("myLinks");
  EventUtil.addHandler(list, "click", function(event) {
      event = EventUtil.getEvent(event);
      var target = EventUtil.getTarget(event);
      switch (target.id) {
          case "doSomething":
              document.title = "I changed the document's title";
              break;
          case "goSomewhere":
              location.href = "http://www.wrox.com";
              break;
          case "sayHi":
              alert("hi");
              break;
      }
  });
  ```
 所有用到按钮的事件(多数鼠标事件和键盘事件)都适合采用事件委托技术。优点如下
 * document对象很快就可以访问到，而且可以在页面生命周期的任何时点上为它添加事件处理程序(无需等待DOMContentLoad或load事件)。只要可单击的元素呈现在页面上，就可以立即具备适当的功能。
 * 在页面中何止事件处理程序所需的事件更少。只添加一个事件处理程序所需的DOM引用更少，所花的时间也更少。
 * 整个页面占用的内存空间更少，能够提升整体的性能。
 最适合的事件有:click，mousedown，keydown，keyup，keypress。

 * ### 移除事件处理程序
 内存中留有过时不用的"空事件处理程序"也是造成web应用程序内存与性能问题的主要原因。在两种情况下可能造成这个问题:
  * 从文档中移除带有事件处理程序的元素时。例如使用innerHTML替换页面中的某一部分的时候。如果你知道某个元素即将被移除，那么最好手工移除事件处理程序，:
  ```html
    <div id="myDiv">
      <input type="button" value="Click Me" id="myBtn">
    </div>
    <script type="text/javascript">
      var btn = document.getElementById("myBtn");
      btn.onclick = function() {
          //先执行某些操作
          btn.onclick = null; //移除事件处理程序
          document.getElementById("myDiv").innerHTML = "Processing...";
      };
    </script>
  ```
 * 导致"空事件处理程序"的另一种情况，就是卸载页面的时候。

## 模拟事件
事件，就是网页中某个特别值得关注的瞬间。事件经常由用户操作或通过其他浏览器功能来触发。
 * DOM中的事件模拟
 可以在document对象上使用createEvent()方法创建Event对象。这个方法接收一个参数，即表示要创建事件类型的字符串。在DOM2级中为复数形式，而在DOM3级中都变成了单数。这些字符可以是下列字符之一:
  * UIEvents
  * MouseEvents
  * MutationEvents
  * HTMLEvents
 模拟事件的最后一步就是触发事件。这一步需要使用dispatchEvent()方法，所有支持事件的DOM节点都支持这个方法。需要传入一个参数，即表示要触发事件的event对象。

## 小结
事件是将JavaScript与网页联系在一起的主要方式。
 在使用事件时，需要考虑如下一些内存与性能方面的问题:
 * 有必要限制一个页面中事件处理程序的数量、数量太多会导致占用大量内存。
 * 简历在事件冒泡机制之上的事件委托技术，可以有效地减少事件处理程序的数量。
 * 建议在浏览器卸载页面之前移除页面中的所有事件处理程序。
