---
title: 《JS高级程序》函数表达式[2]
date: 2016-12-17
---
* #### 静态私有变量
通过在私有作用域中定义私有变量和函数，同样也可以创建特权方法，其基本模式:
```js
 (function(){
   // 私有变量和私有函数
   var privatevariable = 10;
   function privateFunction(){
     return false;
   }
   构造函数
   MyObject = function(){

   };

   // 公有特权方法
   MyObject.prototype.publicMethod = function(){
     privateVariable ++;
     return privateFunction();
   }
 })();
```
这种模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。再私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数机器公有方法。公有方法是在其原型上定义的，这一点体现了典型的原型模式。这种模式与在构造函数中定义特权方法的主要区别，就在于私有变量和函数是由实例共享的。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。以这种方式创建静态私有变量会因为使用原型增进代码服用，但每个实例都么有自己的私有变量。

* #### 模块模式
前面两种模式是用于为自定义类型创建私有变量和特权方法的。而模块模式则是为单例创建私有变量和特权方法。所谓单例，指的就是只有一个实例的对象。就JavaScript是以对象字面量的方式来创建单例对象的。
```js
 var singleton = {
   name:value,
   method:function(){
     // 这里是方法的代码
   }
 }
```
模块模式通过给单例添加私有变量和特权方法能够使其得到增强
```js
 var singleton = function() {
   // 私有变量和私有函数
   var privatevariable = 10;
   function privateFunction(){
     return false;
   }
   return{
     privateVariable ++;
     return privateFunction();
   }
 }
```
这个模块模式使用了一个返回对象的匿名函数。这个范湖的对象字面量定义的是单例的公共接口。这个模式需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的:
```js
 var application = function(){
   // 私有变量和函数
   var component = new Array();
   // 初始化
   component.push(new BaseComponent());
   // 公共
   return {
     getComponentCount: function(){
       return component.length;
     },
     registerComponent: function(){
       if(typeof component == "Object"){
         component.push(component);
       }
     }
   }
 }
```
简言之，如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么久可以使用模块模式。以这种模式创建的每个单例都是Object的实例，因为最终要通过一个对象字面量来表示它。

* #### 增强的模块模式
该模式使用于单例必须是某种类型的实例，同事还必须添加某些属性或方法对其加以增强的情况。
```js
 var singleton = function(){
   // 私有变量和私有函数
   var privatevariable = 10;
   function privateFunction(){
     return false;
   }
   // 创建对象
   var Object = new CustomType();

   // 添加特权/公有属性和方法
   Object.publicProperty = true;
   Object.publicMethod = function(){
     privateVariable ++;
     return privateFunction();
   }

   // 返回这个对象
   return Object;
 }
```

## 小结
* 递归函数应该始终使用argument.callee来递归地调用自身，不要使用函数名，函数名可能发生变化
* 当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量:
  * 在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域。
  * 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁，但是函数返回了一个闭包是，这个函数的作用域将会一直在内存中保存到闭包不存在为止。
* 使用闭包可以在JavaScript中模仿块级作用域
 * 创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。
 * 结果就是函数内部的所有变量都会被立即销毁，除非将某些变量赋值给了包含作用域中的变量。
* 闭包还可以用于在对象中创建私有变量，相关概念和药店如下。
 * 即使JavaScript中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量。
 * 有权访问私有变量的公有方法叫做特权方法。
 * 可以使用构造函数模式、原型模式、来实现自定义的特权方法，也可以使用模块模式和增强模块模式来实现单例的特权方法。
