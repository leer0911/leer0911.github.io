---
title: 数据结构与算法
---
# 列表

列表的抽象数据类型和定义,列表是一种最自然的数据组织方式。以下是如果使用List类将数据组织成一个列表。
```js
function List() {
	this.listSize = 0;
	this.pos = 0;
	this.dataStore = []; // 初始化一个空数组来保存列表元素
	this.clear = clear;
	this.find = find;
	this.toString = toString;
	this.insert = insert;
	this.append = append;
	this.remove = remove;
	this.front = front;
	this.end = end;
	this.prev = prev;
	this.next = next;
	this.length = length;
	this.currPos = currPos;
	this.moveTo = moveTo;
	this.getElement = getElement;
	this.length = length;
	this.contains = contains;
}

function append(element) {
	this.dataStore[this.listSize++] = element;
}

function find(element) {
	for (var i = 0; i < this.dataStore.length; ++i) {
		if (this.dataStore[i] == element) {
			return i;
		}
	}
	return -1;
}

function remove(element) {
	var foundAt = this.find(element);
	if (foundAt > -1) {
		this.dataStore.splice(foundAt,1);
		--this.listSize;
		return true;
	}
	return false;
}

function length() {
	return this.listSize;
}

function toString() {
	return this.dataStore;
}

function insert(element, after) {
	var insertPos = this.find(after);
	if (insertPos > -1) {
		this.dataStore.splice(insertPos+1, 0, element);
		++this.listSize;
		return true;
	}
	return false;
}

function clear() {
	delete this.dataStore;
	this.dataStore = [];
	this.listSize = this.pos = 0;
}

function contains(element) {
	for (var i = 0; i < this.dataStore.length; ++i) {
		if (this.dataStore[i] == element) {
			return true;
		}
	}
	return false;
}

function front() {
	this.pos = 0;
}
function end() {
	this.pos = this.listSize-1;
}
function prev() {
	if (this.pos > 0) {
		--this.pos;
	}
}
function next() {
	if (this.pos < this.listSize-1) {
		++this.pos;
	}
}
function currPos() {
	return this.pos;
}
function moveTo(position) {
	this.pos = position;
}
function getElement() {
	return this.dataStore[this.pos];
}
```

# 栈
栈数据结构的数据只能在栈顶添加或删除,它是一种特殊的列表，栈内的元素只能通过列表的一端访问。这一端称为栈顶。栈被称为一种后入先出的数据结构。

对栈的两种主要操作时将元素压入栈和将一个元素弹出栈。

```js
function Stack() {
	this.dataStore = [];
	this.top = 0;
	this.push = push;
	this.pop = pop;
	this.peek = peek;
}
function push(element) {
	this.dataStore[this.top++] = element;
}
function pop() {
	return this.dataStore[--this.top];
}
function peek() {
	return this.dataStore[this.top-1];
}
function length() {
	return this.top;
}

function clear() {
	this.top = 0;
}
```

可以将数字 转化为二至九进制的数字：

```js
function mulBase(num, base) {
	var s = new Stack();
	do {
		s.push(num % base);
		num = Math.floor(num /= base);
	} while (num > 0);
	var converted = "";
	while (s.length() > 0) {
		converted += s.pop();
	}
	return converted;
}
```

## 回文
回文是指这样一种现象： 一个单词、 短语或数字， 从前往后写和从后往前写都是一样的

判断给定字符串是否是回文

```js
function isPalindrome(word) {
    var s = new Stack();
    for (var i = 0; i < word.length; ++i) {
        s.push(word[i]);
    }
    var rword = "";
    while (s.length() > 0) {
        rword += s.pop();
    }
    if (word == rword) {
        return true;
    } else {
        return false;
    }
}
var word = "hello";
if (isPalindrome(word)) {
    print(word + " is a palindrome.");
} else {
    print(word + " is not a palindrome.");
}
word = "racecar"
if (isPalindrome(word)) {
    print(word + " is a palindrome.");
} else {
    print(word + " is not a palindrome.");
}
```

使用栈模拟递归过程

```js
function fact(n) {
    var s = new Stack();
    while (n > 1) {
        s.push(n--);
    }
    var product = 1;
    while (s.length() > 0) {
        product *= s.pop();
    }
    return product;
}
print(factorial(5)); // 显示 120
print(fact(5)); // 显示 120
```

# 队列
队列是一种列表,不同的是队列只能在队尾插入元素,在队首删除元素。队列用于存储按顺序排列的数据，先进先出，这点和栈不一样。

准备开始实现 Queue 类， 先从构造函数开始：

```js
function Queue() {
	this.dataStore = [];
	this.enqueue = enqueue;
	this.dequeue = dequeue;
	this.front = front;
	this.back = back;
	this.toString = toString;
	this.empty = empty;
}
```

# 链表
链表是一组节点组成的集合。每个节点都使用一个对象的引用指向它的后续。指向另一个节点的引用叫做链。

# 字典
字典是一种以键值对形式存储的数据结构。

# 基本排序算法

生成随机数组
```js
var a = [];
for (var i = 0; i < 99; i++) {
  a.push(num())
}

function num() {
  var random = Math.random()
  var num = Math.floor(random*30+1 );
  return num;
}

```

## 冒泡排序
最慢的排序算法之一,但也是一种最容易实现的排序算法。
