---
title: 'ECMASCript6[2]'
---

# Proxy概述

proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种"元编程"，即对编程语言进行编程。

proxy可以理解成，在目标对象之前架设一层"拦截",外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy这个词的原意是代理，用在这里表示由它来"代理某些操作",可以译为"代理器"。

```javascript
var obj = new Proxy({},{
    get:function(target,key,receiver){
      console.log(`getting ${key}!`);
      return Reflect.get(target,key,receiver);
    },
    set:function(target,key,value,receiver){
      console.log(`setting ${key}!`);
      return Reflect.set(target,key,value,receiver);
    }
  });
```

上面代码对一个空对象架设了一层拦截，重定义了属性的读取和设置行为。会得到如下结果

```javascript
obj.count=1
  // setting count!
  ++obj.count
  // getting count!
  // setting count!
  // 2
```

上面代码说明了，Proxy实际上重载(overload)了点运算符，即用自己的定义覆盖了语言的原始定义。

ES6原生提供Proxy构造函数，用来生成Proxy实例。

```javascript
var proxy = new Proxy(target,handler);
```

Proxy对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target表示要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。

```javascript
var proxy = new Proxy({},{
    get:function (target,property) {
      return 35;
    }
  });
  proxy.time //35
  proxy.name //35
  proxy.title //35
```

上面代码中，作为构造函数，Proxy接收两个参数。第一个参数是要代理的目标对象，即如果没有Proxy的介入，操作原来要访问的就是这个对象;第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作

Proxy.revocable方法返回一个可取消的Proxy实例。

```javascript
let target = {};
let handler = {};

let {proxy, revoke} = Proxy.revocable(target, handler);

proxy.foo = 123;
proxy.foo // 123

revoke();
proxy.foo // TypeError: Revoked
```

# Reflect 概述

Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。

- 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。
- 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。
- 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。

# Promise对象

Promise是异步编程的一种解决方案，比传统的解决方案--回调函数和事件更合理和更强大。所谓Promise,简单说就是一个容器，里面保存着某个未来才会结束的事件(通常是一个异步操作)的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。

Promise对象有以下两个特点。

- 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态:Pending(进行中)，Resolved(已完成，又称fulfilled)和Rejected(已失败)。只有异步操作的结果，可以决定当前是哪一个状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来。
- 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能:从Pending变为Resolved和从Pending变为Rejectd。只要这两种情况发生，状态就凝固了，不会再变了，也会立即得到这个结果。这与事件完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。
- 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供了统一的接口，使得控制异步操作更加容易。
- Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

## 基本用法

Promise对象是一个构造函数，用来生成Promise实例。

```javascript
var promise = new Promise(function (resolve,reject) {
    // body...
    if (true) {
      resolve(value);
    }else{
      reject(error)
    }
  })
```

Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。

resolve函数的作用是，将Promise对象的状态从"未完成"变成"成功"(即从Pending变为Resolved)，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去;reject函数的作用是，将Promise对象的状态从"未完成"变为失败(即从Pending变为Rejected)，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。

Promise实例生成以后，可以用then方法分别制定Resolved状态和Reject状态的回调函数。

```javascript
Promise.then(function (value) {
    // success...
  },function(error) {
    // failure...
  });
```

then方法可以接受两个回调函数作为参数。第一个回调函数时Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为reject时调用。其中第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出去的值作为参数。

```javascript
function timeout(ms) {
    // body...
    return new Promise((resove,reject)=>{
      setTimeout(resolve,ms,'done');
    })
  }
  timeout(100).then((value)=>{
    console.log(value);
  })
```

上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间(ms参数)以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。

Promise新建后就会立即执行。

```javascript
let promise = new Promise(function(resolve, reject) {
console.log('Promise');
resolve();
});

promise.then(function() {
console.log('Resolved.');
});

console.log('Hi!');

// Promise
// Hi!
// Resolved
```

上面代码中，Promise新建后立即执行，所以首先输出的是"Promise"。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以"resolved"最后输出。

下面是异步加载图片的例子。

```javascript
function loadImagesAsync(url) {
    // body...
    return new Promise(
      function (resolve,reject) {
        var image = new Image();
        image.onload = function () {
          resolve(image);
        };
        image.onerror = function(){
          reject(new Error('Could not load image at' + url));
        };

        image.src = url;

      }
    )
  }
```

上面代码中，使用了Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则调用reject方法。

下面是一个用Promise对象实现Ajax操作的例子。

```javascript
var getJSON = function(url) {
    var promise = new Promise(function(resolve,reject) {
      var client = new XMLHttpRequest();
      client.open("GET",url);
      client.onreadystatechange = handler;
      client.responseType = "json";
      client.setRequestHeader("Accept","application/json");
      client.send();

      function handler() {
        if(this.readyState !==4){
          return;
        }
        if(this.status===200){
          resolve(this.response);
        }else{
          reject(new Error(this.statusText));
        }
      };
    });
    return promise;
  }

  getJSON("/posts.json").then(function (json) {
    console.log('contents:'+json);
  },function(error) {
    console.error('出错了',error);
  })
```

上面代码中，getJSON时对XMLHttpRequest对象的封装，用于发出一个针对json数据的HTTP请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。

如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常死Error对象的实例，表示抛出的错误;resolve函数的参数除了正常的值以外，还可能是另一个Promise实例，表示异步操作的结果有可能是一个值，也有可能是一个异步操作。

```javascript
var p1 = new Promise(function (resolve,reject) {
    // body...
  })

  var p2 = new Promise(function (resolve,reject) {
    // body...
    resolve(p1);
  })
```

上面代码中，p1和p2都是Promise的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。

注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。

## then

Promise实例具有then方法，也就就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。then方法的第一个参数是resolved状态的回调函数，第二个参数(可选)是reject状态的回调函数。

then方法返回的是一个新的Promise实例(注意，不是原来那个Promise实例)。因此可以采用链式写法，即then方法后面再调用另一个then方法。

```javascript
getJSON("/post.json").then(
    function (json) {
      // body...
      return json.post;
    }).then(function (post) {
      // body...
    })
```

上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。

采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象(即有异步操作)，这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。

```javascript
getJSON("/post/1.json").then(function (post) {
    return getJSON(post.commentURl);
  }).then(function funcA(comments) {
    console.log("Resolved:",comments);
  },function funcB(err) {
    console.log("Rejected:",err);
  });
```

## catch

Promise.prototype.catch方法是.then(null,rejection)的别名，用于指定发生错误时调用的回调函数。

```javascript
getJSON("/posts.json").then(function (post) {
    // body...
  }).catch(function(error) {
    // body...
    console.log('发生错误!',error);
  })
```

## all

Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。

`var p = Promise.all([p1,p2,p3]);`

上面代码中，Promise.all方法接受一个数组组作为参数，参数可以不是数组，但必须具有iterator接口，且返回的每个成员都是Promise实例。

# 异步操作和Async函数

JavaScript语言的执行环境是"单线程"的，如果没有异步编程，根本没法用，非卡死不可。

ES6诞生之前，异步编程的方法，大概有:

- 回调函数
- 事件监听
- 发布/订阅
- Promise对象

ES6将JavaScript异步编程带入了一个全新的阶段，ES7的Async函数更是提出了异步编程的终极解决方案。

## 基本概念

### 异步

所谓异步，简单说就是一个任务分为两段，先执行一段，然后转而执行其他任务，等做好了准备，再回头执行第二段。

比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段(处理文件)。这种不连续的执行，就叫做异步。

相应地，连续的执行叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。

### 回调函数

JavaScript语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。

```javascript
fs.readFile('/etc/passwd',function (err,data) {
    if(err)throw err;
    console.log(data);
  })
```

上面代码中，readFile函数的第二个参数，就是回调函数，也就是任务的第二段。等操作系统返回了文件后，回调函数才会执行。

### Promise

回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件。

```javascript
fs.readFile(fileA,function (err,data) {
    // body...
    fs.readFile(fileB,function (err,data) {
      // body...
    })
  })
```

不难想象，如果一次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况被称为"回调函数地狱"。

Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，雨荨将回调函数的嵌套，改成链式调用。采用Promise，连续读取多个文件，写法如下。

```javascript
var readFile = require('fs-readfile-promise');
  readFile(fileA).then(function (data) {
    // body...
    console.log(data.toString());
  })
  .then(function (argument) {
    // body...
  })
```

上面代码中，使用了fs-readfile-promise模块，它的作用就是返回一个Promise版本的readFile函数。Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。

可以看到，Promise的写法只是回调函数的改进，使用了then方法以后，异步任务的两段执行看得更清楚了，除此之外，并无新意。Promise的最大问题是代码冗余。

### Generator函数

#### 协程

传统的编程语言，早有异步编程的解决方案(其实是多文物的解决方案)。其中有一种叫做"协程"(coroutine)，意思是多个线程互相协作，完成异步任务。协程有点像函数，又有点像线程。它的运行流程大致如下。

- 协程A开始执行。
- 协程A执行到一半，进入暂停，执行权转移到协程B。
- (一段时间后)协程B交还执行权。
- 协程A回复执行。

上面流程的协程A，就是异步任务，因为它分成两段(或多段)执行。

```javascript
function *asyncJob() {
    // body...
    var f =  yield readFile(fileA);
  }
```

上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。

协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码写的非常像同步操作，如果去除yield命令，简直一模一样。

### Generator函数的概念

Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权(即暂停执行)。

整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。Generator函数的执行方法如下。

```javascript
function *gen(x) {
    // body...
    var y = yield x + 2;
    return y;
  }
  var g = gen(1);
  g.next();
```

### Thunk函数

#### 参数的求值策略

```javascript
var x = 1;
  function f(m) {
    // body...
    return m * 2;
  }
  f(x+5)
```

上面代码先定义函数f，然后向它传入表达式x+5，传值调用和传名调用。

### Thunk函数的含义

编译器的传名调用，往往是将参数放到一个临时函数之中，再将找个临时函数传入函数体。这个临时函数就叫做Thunk函数。

```javascript
function f(m) {
    // body...
    return m * 2;
  }
  f(x+5);

  //等同于

  var thunk = function () {
    // body...
    return x + 5;
  };

  function f(thunk) {
    // body...
    return thunk() * 2;
  }
```

这就是Thunk函数的定义，它是"传名调用"的一种实现策略，用来替换某个表达式。

### JavaScript语言的Thunk函数

JavaScript语言是传值调用，它的Thunk函数含义有所不同。在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。

```javascript
// 正常版本的readFile(多参数版本)
  fs.readFile(fileName,callback);

  // Thunk版本的readFile(单参数版本)
  var readFileThunk = Thunk(fileName);
  readFile(callback);

  var Thunk = function (fileName) {
    return function (callback) {
      return fs.readFile(fileName,callback);
    };
  };
```

上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它编程了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做Thunk函数。

任何函数，只要参数有回调函数，就能写成Thunk函数的形式。下面是一个简单的Thunk函数转换器。

```javascript
//ES5版本
  var Thunk = function (fn) {
    // body...
    return function () {
      var args = Array.prototype.slice.call(argument);
      return function (callback) {
        args.push(callback);
        return fn.apply(this,args);
      }
    };
  };

  // ES6版本
  var Thunk = function (fn) {
    return function (...args) {
      return function (callback) {
        return fn.call(this,...args,callback);
      }
    };
  };
```

### Generator函数的流程管理

Thunk函数现在可以用于Generator函数的自动流程管理。

Generator函数可以自动执行。

```javascript
function * gen() {
    // body...
  }
  var g = gen();
  var res = g.next();

  while (!res.done) {
    console.log(res.value);
    res = g.next();
  }
```

上面代码中，Generator函数gen会自动执行完所有步骤。

但是,这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时Thunk函数就能派上用处。

### Thunk函数的自动流程管理

Thunk函数的真正的威力，在于可以自动执行Generator函数。下面就是一个基于Thunk函数的Generator执行器。

```javascript
function run(fn) {
    var gen = fn();
    function next(err,data) {
      var result = gen.next(data);
      if (result.done) return;
      result.value(next);
    }
    next();
  }
  function *g() {

  }
  run(g);
```

# class

## class基本语法

JavaScript语言的传统方法是通过构造函数，定义并生成新对象。

```javascript
function Point(x,y) {
    this.x = x;
    this.y = y;
  }
  Point.prototype.toString = function () {
    return '(' + this.x + ',' + this.y + ')';
  };

  var p = new Point(1,2);
```

用ES6的"类"改写:

```javascript
//定义类
  class Point{
    constructor(x,y){
      this.x
      this.y
    }
  }
  toString(){
    return '(' + this.x + ',' + this.y + ')';
  }
```

类的数据类型就是函数，类本身就指向构造函数。

使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。

```javascript
class Bar{
  doStuff(){
    console.log('stuff');
  }
}

var b = new Bar();
b.doStuff()
```

Object.assign方法可以很方便地一次向类添加多个方法。

```javascript
class Point{
  constructor(){

  }
}

Object.assign(Point.prototype,{
  toString(){},
  toValue(){}
});
```

prototype对象的constructor属性，直接指向"类"的本身。

类的内部所有定义的方法，都是不可枚举的

## constructor方法

constructor方法是类默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加

constructor方法默认返回实例对象(即this)，完全可以指定返回另外一个对象。

实例的属性除非显式定义在其本身(即定义在this对象上)，否则都是定义在原型上(即定义在class上)。

## 不存在变量提升

class不存在变量提升(hoist)

```javascript
new Foo(); // ReferenceError
  class Foo{}
```

## class表达式

与函数一样，类也可以使用表达式的形式定义。

```javascript
const Myclass = class Me{
    getClassName(){
      return Me.name;
    }
  };
```

采用class表达式，可以写出立即执行的Class。

```javascript
let person = new class{
    constructor(name){
      this.name = name;
    }
    sayName(){
      console.log(this.name);
    }
  }('张三');

  person.sayName();
```

## 私有方法

私有方法是常见需求，但ES6不提供。只能通过变通方法模拟实现。

一种是在命名上加以区别。

```javascript
class Widget{
     // 公有方法
     foo (baz){
       this._bar(baz)
     }

     // 私有方法
     _bar(baz){
       return this.snaf = baz;
     }
   }
```

另一种方法索性将私有方法移除模块，因为模块内部的所有方法都是对外可见的。

还有一种是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。

```javascript
const bar = Symbol('bar');
  const snaf = Symbol('snaf');

  export default class myClass{
    // 公有方法
    foo(baz){
      this[bar](baz);
    }

    //私有方法
    [bar](baz){
      return this[snaf] = baz;
    }
  }
```

## this的指向

类的方法内部如果含有this,它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很有可能报错。

```javascript
class Logger{
    printName(name = 'there'){
      this.print(`hello${name}`);
    }

    print(text){
      console.log(text);
    }
  }

  const logger = new Logger();
  const {printName} = logger;
  printName();
```

## Class的继承

### 基本用法

Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。

```javascript
class ColorPoint extends Point{}
```

上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。

```javascript
class ColorPoint extends Point {
    constructor(x,y,color){
      super(x,y);
      this.color = color;
    }

    toString(){
      return this.color + '' + super.toString();
    }
  }
```

上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。

子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。

另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。

```js
class Point{
  constructor(x,y){
    this.x = x;
    this.y = y;
  }
}

class ColorPoint extends Point {
  constructor(x,y,color){
    this.color = color;
    super(x,y);
    this.color = color;
  }
}
```

## 类的prototype属性和__proto__属性
class作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。

- 子类的__proto__属性，表示构造函数的继承，总是指向父类。
- 子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。

```js
  class A {}
  class B extends A{}

  B.__proto__ === A
  B.prototype.__proto__ === A.prototype

```

## Extends 的继承目标

extends关键字后面可以跟多种类型的值。

```js
  class B extends A{

  }
```

只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性，因此A可以是任意函数。

第一种特殊情况，子类继承Object类。

```js
  Class A extends Object {}
  A.__proto__ === Object
  A.prototype.__proto__ === Object.prototype
```

这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。

第二种特殊情况，不存在任何继承。

```js
  class A {}
  A.__proto__ === Function.prototype
  A.prototype.__proto__ === Object.prototype
```

这种情况下,A作为一个基类(即不存在任何继承)，就是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回一个空对象(即Object实例)，所以A.prototype.`__proto__`指向构造函数(Object)的prototype属性。

第三种特殊情况，子类继承null。
```js
  class A extends null{}

  A.__proto__ === Function.prototype
  A.prototype.__proto__ === undefined

```

## `Objcet.getPrototypeOf()`
`Objcet.getPrototypeOf()`方法可以用来从子类上获取父类。因此可以使用这个方法判断，一个类是否继承了另一个类。

## super关键字
super这个关键字，即可以当做函数使用，也可以当做对象使用。在这两种情况下，它的用法完全不同。

第一中情况，super作为函数调用时，代表父类的构造函数。ES6要求，子类的构造函数必须执行一次super函数。

```js
  class A {}
  class B extends A {
    constructor(){
      super();
    }
  }
```

作为函数时,super()只能用在子类的构造函数之中，用在其他地方会报错。

```js
  class A{}

  class B extends A {
    m(){
      super();//报错
    }
  }
```

第二种情况，super作为对象时，指向父类的源性对象。

```js
  class A {
    P(){
      return 2;
    }
  }

  class B extends A {
    constructor(){
      super();
      console.log(super.p());//1
    }
  }

  let b = new B();
```

上面代码中，子类B当中的super.p()，就是将super当做一个对象使用。这时，super指向A.prototype，所以super.p()就相当于A.prototype.p()。

这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。

```js
  class A{
    constructor(){
      this.p = 2;
    }
  }

  class B extends A {
    get m(){
      return super.p;
    }
  }

  let b = new B();
  b.m //undefined
```

上面代码中，p是父类A实例的属性，super.p就引用不到它。

如果属性定义在父类的原型对象上，super就可以取到。

```js
  class A{}
  A.prototype.x = 2;

  class B extends A {
    constructor(){
      super();
      console.log(super.x);
    }
  }

  let b = new B();
```

上面代码中，属性X是定义在A.prototype上面的，所以super.x可以取到它的值。

通过super调用父类的方法时，super会绑定子类的this。

```js
  class A {
    constructor(){
      this.x = 1;
    }
    print(){
      console.log(this.x);
    }
  }

  class B extends A {
    constructor(){
      super();
      this.x=2;
    }
    m(){
      super.print();
    }
  }

  let b = new B();
  b.m()
```

## 实例的__proto__属性

子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，式父类的原型。

## 原生构造函数的继承

原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有:

- Boolean
- Number
- String
- Array
- Date
- Function
- RegExp
- Error
- Object

以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。

## class的取值函数(getter)和存值函数(setter)

class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。

```js
  class MyClass {
    constructor(){

    }
    get prop(){
      return 'getter';
    }
    set prop(value) {
      console.log('setter:'+value);
    }
  }

  let inst = new MyClass();

  inst.prop = 123;
  // setter:123
  inst.prop
  //'getter'
```
上面代码中，prop属性有对应的存值函数和取值函数，因此赋值的读取行为都被自定义了。

存值函数和取值函数是设置在属性的descriptor对象上的。

## class的Generator方法

如果某个方法之前加上星号(*)，就表示该方法是一个Generator函数。

```js
  class Foo {
    constructor(...args){
      this.args = args;
    }
    *[Symbol.iterator](){
      for (let arg of this.args) {
        yield arg;
      }
    }
  }

  for (let x of new Foo('hello','world')) {
    console.log(x);
  }
```

## class的静态方法

类相当于实例的原型，所有在勒种定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就成为静态方法。

```js
  class Foo {
    static classMethod(){
      return 'hello'
    }
  }

  Foo.classMethod()

  var foo = new Foo();
  foo.classMethod()
```

上面代码中，foo类的classMethod方法前有static关键字，表明方法是一个静态方法，可以直接在Foo类上调用，而不是在Foo类的实例上调用。如果在实例还是那个调用静态方法，会抛出一个错误，表示不存在该方法就会

父类的静态方法，可以被子类继承。

```js
class Foo {
  static classMethod(){
    return 'hello';
  }
}

class Bar extends Foo{}

Bar.classMethod();
```

静态方法也是可以从super对象上调用的。

## class静态属性和实例属性
静态属性指的是class本身的属性，即Class.propname，而不是定义在实例对象(this)上的属性。
```js
  class Foo {

  }
  Foo.prop = 1;
  Foo.prop
```

上面的写法为Foo类定义了一个静态属性prop。目前只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。

ES7有一个静态属性的提案，类的实例属性可以用等式，写入类的定义之中。同样适用static关键字也可以。

## new.target属性
new是从构造函数生成实例的命令。ES6为new命令引入了一个new.target属性，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此中国属性可以用来确定构造函数是怎么调用的。

```js
  function Person(name) {
    if (new.target !== undefined) {
      this.name = name;
    }else{
      throw new Error('必须使用new生成实例');
    }
  }

  // 另一种写法
  function Person(name) {
    if(new.target === Person){
      this.name = name;
    }else{
      throw new Error('必须使用new生成实例');
    }
  }

  var person = new Person('张三');
  var notAPerson = Person.call(person,'张三')
```

## Mixin模式的实现
Mixin模式指的是，将多个类的接口"混入"(mixin)另一个类。

```js
  function mix(...mixins) {
    class Mix{}

    for(let mixin of mixins){
      copyProperties(Mix,mixin)
      copyProperties(Mix.prototype,mixin.prototype);
    }

    return Mix;
  }

  function copyProperties(traget,source) {
    for (let key of Reflect.ownKeys(source)) {
      if (key !== "constructor"&&key!=="prototype" && key!=="name") {
        let desc = Object.getOwnPropertyDescriptor(source,key);
        Object.defineProperty(target,key,desc);
      }
    }
  }
```

上面代码的mix函数，可以将多个对象合成一个类。使用的时候只要继承中国类即可。

# 修饰器

## 类的修饰
修饰器(Decorator)是一个函数，用来修改类的行为。修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。

```js
  function testable(target) {
    target.isTestbale = true;
  }
  @testalbe
  class MyTestableClass{}

  console.log(MyTestableClass.isTestbale);
```

上面代码中，@testable就是一个修饰器。它修改了MyTestableClass这个类的行为，为它加上了静态属性isTestable。

基本上，修饰器的行为就是下面这样。

```js
  @decorator
  class A{}

  // 等同于

  class A {}
  A = decorator(A) || A;
```
也就是说，修饰器本质就是编译时执行的函数。

修饰器函数的第一个参数，就是所要修饰的目标类。


## 为什么修世起不能用于函数?
修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。

```js
  var counter = 0;
  var add = function(){
    counter++;
  };
  @add
  function foo() {
    // body...
  }
```

## `core-decorators.js`

core-Decorator.js是个第三方模块，提供了几个常见的修饰器

- autobind是的方法中的this对象，绑定原始对象。
- readonly修饰器是的属性或方法不可写。
- override修饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。

## 使用修饰器实现自动发布事件
我们可以使用修饰器，使得对象的方法被调用时，自动发出一个事件。

# Module
历史上，JavaScript一直没有模块(module)体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，已经输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。

```js
  let{stat,exists,readFile}=require('fs');

  let _fs = require('fs');
  let stat = _fs.stat;

```

这种加载称为"运行时加载"，因为只有运行时才能得到这个对象，导致完全没办法在编译时做"静态优化"。ES6模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。

```js
  import{stat} from 'fs';
```

这种称为编译时加载或者静态加载，即ES6在编译时就完成模块加载，效率比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。

## 严格模式
- 变量必须声明后再使用
- 函数的参数不能有同名属性，否则报错
- 不能使用with语句
- 不能对只读属性赋值
- 不能使用前缀O表示八进制数
- 不能删除不可删除的属性
- 不能删除变量delete prop，只能删除属性`delete global[prop]`
- eval不会在它的外层作用域引入变量
- eval和arguments不能被重新赋值
- arguments不会自动反映函数参数的变化
- 不能使用arguments.callee
- 不能使用arguments.caller
- 禁止this指向全局对象
- 不能使用fn.caller和fn.arguments获取函数调用的堆栈
- 增加了保留字(比如protected、static和interface)

## export命令

模块功能主要由两个命令构成:export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。

一个模块就是一个独立的文件。文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个js文件，里面使用export命令输出变量。

```js
  export var firstName = 'Micheal';
```

export的写法，除了上面这样，还有另外一种。

```js
 var firstName = 'Micheal';
 export {firstName};
```
上面代码在export命令后面，使用大括号指定所要输出的一组变量。它与前一种写法是等价的，但是应该优先考虑使用这种写法。因为只有就可以在脚本尾部，一眼看清楚输出了哪些变量。export命令除了输出变量，还可以输出函数或类(class)。

```js
  export function multiply(x,y) {
    return x * y;
  }
```
上面代码对外输出一个函数multiply。

通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字充命名。
```js
  function v1() {}
  function v2() {}

  export {
    v1 as streamV1,
    v2 as streamV2,
    v2 as streamLatestVersion,
  }
```

上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。另外，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。

export命令可以出现在模块的任何位置，只要处于模块顶层就可以。绕过处于块级作用域内，就会报错。

## import命令
使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块。import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径

由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。

```js
  //报错
  import {'f'+'oo'} from 'my_module';

  //报错
  let module = 'my_module';
  import {foo} from module;

  //报错
  if(x===1){
    import {foo} from 'module1';
  }else{
    import {foo} from 'module2';
  }

```
上面三种写法都会报错，因为它们用到了表达式、变量和if结构。在静态分析节点，这些语法都是没法得到值的。

最后，import语句会执行所加载的模块，因此可以有下面的写法。

## 模块的整体加载

除了指定加载某个输出值，还可以使用整体加载，即用*星号指定一个对象，所有输出值都加载在这个对象上面。

## export default命令
为了让用户不同阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。

export default命令只能使用一次，所以import命令后面才不用加大括号，因为只可能对于一个方法。本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。

## ES6模块加载的实质

ES6模块加载的机制，与CommonJs模块完全不同。CommonJs模块输出的是一个值的拷贝，而ES6模块输出的值的引用。

## 浏览器的模块加载
浏览器使用ES6模块语法如下。
```js
  <script type"module" src="foo.js"></script>
```
对于外部的模块脚本:
- 该脚本自动采用严格模式。
- 该脚本内部的顶层变量，都只在该脚本内部有效，外部不可见。
- 该脚本内部的顶层的this关键字，返回undefined，而不是指向window。
