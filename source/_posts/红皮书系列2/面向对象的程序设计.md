---
title: 面向对象的程序设计
---

面向对象的语言有一个标志，那就是它们都有类的概念。而通过类可以创建任意多个具有相同属性和方法的对象。

ECMA-262把对象定义为"无序属性的集合,其属性可以包含基本值,对象或者函数"。对象的每个属性或方法都有一个名字,而每个名字都映射到一个值。因此可以把 ECMAScript的对象想象成散列表:无非就是一组名值对。

每个对象都是基于一个引用类型创建的，可以是第5章讨论的原生类型，也可以是开发人员定义的类型。

# 理解对象

创建自定义对象最简单的方式就是创建一个Object的实例,然后再为它添加属性和方法,对象字面量称为创建这种对象的首选模式。

# 属性类型

ECMAScript定义只有内部才用的特性时，描述了属性的各种特征。为了表示特性是内部值,把值放在两对中括号里面。 ECMAScript中有两种属性:数据属性和访问器属性。

## 数据属性

数据属性包含一个数据值的位置。在这个位置可以读取和写入值。

数据属性有4个描述其行为的特性:

```
 [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特
性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的
这个特性默认值为 true。
 [[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定
义的属性，它们的这个特性默认值为 true。
 [[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的
这个特性默认值为 true。
 [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，
把新值保存在这个位置。这个特性的默认值为 undefined。
```

对于像前面例子那样直接在对象上定义的属性，它们的`[[configurable]]`，`[[Enumerable]]`和`[[Writable]]`特性都被设置为true,而`[[Value]]`特性被设置为指定的值。

一旦把属性定义为不可配置的,就不能再把它变回可配置了。此时,再调用Object.defineProperty()方法修改除writable之外的特性,都会导致错误。

## 访问器属性

访问器属性不包含数据值;它们包含一对getter和setter函数。在读取访问器属性时,会调用getter函数,这个函数负责返回有效的值;在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性。

```
 [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特
性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为
true。
 [[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这
个特性的默认值为 true。
 [[Get]]：在读取属性时调用的函数。默认值为 undefined。
 [[Set]]：在写入属性时调用的函数。默认值为 undefined。
```

```javascript
var book = {
    _year:2004,
    edition:1
  };

  Object.defineProperty(book,"year",{
    get:function () {
      return this._year;
    },
    set:function(newValue){
      if (newValue>2004) {
        this._year = newValue;
        this.edition += newValue - 2004;
      }
    }
  });

  book.year = 2005;
  alert(book.edition)
```

_year前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。访问器属性的常见方式,即设置一个属性的值会导致其他属性发生变化。

不一定非要同时制定getter和setter。只指定getter意味着属性是不能写的，尝试写入属性会被忽略。尝试写入只指定了getter函数的属性会抛出错误。类似地,只指定setter函数的属性也不能读,否则在非严格模式下回返回undefined,而在严格模式下回抛出错误。

在这个方法之前,要创建访问器属性，一般都使用两个非标准的方法:`__defineGetter()__`和`__defineSetter()__`

## 定义多个属性

可以使用`Object.defineProperties()`

```javascript
var book = {};
Object.defineProperties(book,{
  _year:{
    value:2004
  },
  edition:{
    value:1
  },
  year:{
    get:function(){
      return this._year;
    },
    set:function(){
      if(newValue > 2004){
        this._year = newValue;
        this.edition += newValue - 2004;
      }
    }
  }
})
```

## 读取属性的特性

```javascript
var book = {};
  Object.defineProperties(book,{
    _year:{
      value:2004
    },
    edition:{
      value:1
    },
    year:{
      get:function () {
        return this._year;
      },
      set:function (newValue) {
        if (newValue > 2004) {
          this._year = newValue;
          this.edition +=  newValue - 2004;
        }
      }
    }
  });

  var descriptor = Object.getOwnPropertyDescriptor(book,'year');
```

## 创建对象

虽然Object构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点:使用同一个接口创建很多对象，会产生大量重复代码。为解决这个问题,人们开始使用工厂模式的一种变体。

### 工厂模式

这种模式抽象了创建具体对象的过程，考虑到 ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节。

```javascript
function createPerson(name,age,job) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function () {
      alert(this.name);
    }
    return o;
  }

  var person1 = createPerson('Nicholas',29,'Software Engineer');
  var person2 = createPerson('Greg',27,'Doctor');
```

**工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。**

### 构造函数模式

ECMAScript总的构造函数可以用来创建特定类型的对象。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。此外,也可以创建自定义的构造函数。从而定义自定义对象类型的属性和方法。

```javascript
function Person(name,age,job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function() {
      return this name;
    }
}

var person1 = new Person('li',29,'fen');
var person2 = new Person('yi',29,'fen');
```

没有显示地创建对象,直接将属性和方法赋给了this对象,没有return语句。

使用new操作符实际经历了以下4个步骤:

- 创建一个新对象;
- 将构造函数的作用域赋给新对象(因此this就指向了这个新对象);
- 执行构造函数中的代码(为这个新对象添加属性);
- 返回新对象。

```javascript
alert(person1.constructor == Person);
  alert(person2.constructor == Person);
```

对象的constructor属性最初是用来标识对象类型的。

**创建自定义构造函数意味着将来可以将它的实例标识为一种特定的类型;而这正是构造函数模式胜过工厂模式的地方。**

以这种方式定义的构造函数是定义在Global对象(在浏览器中是window对象)中的。

调用构造函数而不使用new操作符调用,属性和方法都被添加给window对象了。

使用构造函数的主要问题,就是每个方法都要在每个实例上重新创建一遍。person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例。 ECMAScript中的函数是对象。因此每定义一个函数

## 原型模式

我们创建的每个函数都有一个prototype(原型属性)这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。prototype就是通过调用构造函数而创建的那个对象实例的原型对象。

```javascript
function Person() {
  }
  Person.prototype.name = "a";
  Person.prototype.age = 28;
  Person.prototype.sayName = function () {
    alert(this.name);
  }

  var person1 = new Person();
  var person2 = new Person();

  console.log(person1.sayName == person2.sayName);
```

### 理解原型对象

无论什么时候,只要创建了一个新函数。就会根据一组特定的规则为该函数创建一个prototype属性,这个属性指向函数的原型对象。在默认情况下,所有原型对象都会自动获得一个constructor(构造函数)属性，这个属性包含一个指向prototype属性所在函数的指针。

创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性;至于其他方法，则都是从Object继承而来的。当调用一个构造函数创建一个实例后,该实例的内部将包含一个指针(内部属性),指向构造函数的原型对象。管这个指针叫`[[Prototype]]`虽然脚本中

没有标准的方式访问`[[Prototype]]`,但在Firefox,Safari和Chrome在每个对象上都支持一个属性**proto**;而在其他实现中，这个属性对脚本则是完全不可见的。不过,要明确的真正重要的一点就是,这个连接存在于实例和构造函数原型对象之间。而不存在于实例与构造函数之间。

虽然在所有实现中都无法访问到`[[Prototype]]`,但可以通过`isPrototypeOf()`方法来确定对象之间是否存在这种关系。从本质上讲，如果`[[Prototype]]`指向调用`isPrototype()`方法的对象(Person.prototype),那么这个方法就返回true。

```javascript
console.log(Person.prototype.isPrototypeOf(person1));
  // 因为person1内部有指向Person Prototype的指针,所以返回true
```

ECMAScript5增加了一个新方法。叫做Object.getPrototypeOf(),在所有支持的实现中，这个方法返回`[[Prototype]]`的值。

```javascript
console.log(Object.getPrototypeOf(person1));
  //返回 Person 原型。可以方便地取得一个对象的原型，在实现原型继承上非常有用。
```

**前面提到过,原型最初只包含constructor属性,而该属性也是共享的。因此可以通过对象实例访问。**

虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。

当时中设置了与原型中同名的属性,则会一直阻止访问原型上这个值(设置为null也无用)。只有当使用delete操作符可以完全删除实例属性后才能重新访问原型中的属性。

```javascript
function Person() {
  }
  Person.prototype.name = 'a';

  var person1 = new Person();
  person1.name = 'b';

  console.log();
```

使用hasOwnProperty()方法方法可以检测一个属性是存在u实例中,还是存在于原型中。这个方法(不要忘了是从Object继承而来)只在给定属性存在于对象实例中时，才会返回true。

**ECMAScript5的Object.getOwnPropertyDescriptior()方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用Object.getOwnPropertyDescriptor()方法。**

## 原型与in操作符

有两种方式使用in操作符:单独使用和在for-in循环中使用。在单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。

```javascript
function Person() {
  }
  Person.prototype.name = 'a';
  var person1 = new Person();
  person1.age = 23;

  console.log('name' in person1);//ture 来自原型
  console.log('age' in person1);//true 来自实例
```

in返回实例或原型上有该属性时返回ture,hasOwnProperty当实例上有该属性时返回true。因此要检测属性是否在原型上,可以在in返回true以及hasOwnProperty返回false时确定。

```javascript
function hasPrototypeProperty(object,name){
  return !object.hasOwnProperty(name) && (name in object);
}
```

在使用for-in循环时，返回的是所有能够通过对象访问的。可枚举的(Enumerable)属性。其中即包含存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性(即将`[[Enumerable]]`标记为false的属性)的实例属性也会在for-in循环中返回。因为根据规定，所有开发人员定义的属性都是可枚举的。

ECMAScript 5 也将 constructor 和 prototype 属性的`[[Enumerable]]`特性设置为 false，但并不 是所有浏览器都照此实现。

要取得对象上所有可枚举的实例属性，可以使用 ECMAScript 5 的 Object.keys()方法。这个方法 接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。

如果你想得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法。

Object.keys()和Object.getOwnPropertyName()方法都可以用来替代for-in循环。

## 更简单的原型语法

```javascript
function A() {
  }

  Person.prototype = {
    name:'jj',
    age:29,
    sayName:function () {
      console.log(this.name);
    }
  }
```

**使用这种语法,本质上完全重写了默认的prototype对象，因此constructor属性也就变成了新对象的constructor属性(指向Object构造函数),不再指向Person函数。此时,尽管instanceof操作符还能返回正确的结果，但通过constructor已经无法确定对象的类型了。**

如果constructor的值真的很重要，可以像下面这样特意将它设置回适当的值。

```javascript
// function A() {
//   }
//
//   A.prototype = {
//     constructor:A
//   }
```

注意,这种方式重设constructor属性会导致他们`[[Enumerable]]`特性被设置为true。默认情况下,原生的constructor属性是不可枚举的。因此如果你使用兼容ECMAScript5的JavaScript引擎，可以试一试Object.defineProperty()。

```javascript
function A() {
  }

  A.prototype = {
    name:'a',
    age:29
  }

  Object.defineProperty(A,'constructor',{
    value:A
  })
```

## 原型的动态性

**由于在原型中查找值的过程是一次搜索，因此我们队原型对象中所做的任何修改都能够立即从实例反映出来，即使先创建了实例后修改原型也照样如此**

```javascript
function A() {
  }

  var a = new A();

  A.prototype = {
    constructor:A,
    name:"a",
    age:29,
    sayName:function () {
      alert(this.name);
    }
  }

  a.sayName();//error
```

在这个例子中,我们先创建了Person的一个实例，然后又重写了其原型对象。任何在调用friend.sayName()时发生了错误。

## 原生对象原型

原型模式的重要性不仅仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型都在其构造函数的原型上定义了方法。

## 原型对象的问题

原型模式省略了传递参数这一环节,原型模式最大的问题是由其共享的本质所导致的。对包含引用类型的属性来说,问题比较突出。

```javascript
function A() {
  }

  A.prototype = {
    a:['a','b']
  }

  var a1 = new A();
  var a2 = new A();

  a1.a.push('1');

  console.log(a1.a);//'a,b,1'
  console.log(a2.a);//'a,b,1'
  console.log(a1.a==a2.a);//true
```

## 组合使用构造函数模式和原型模式

```javascript
function Person(name,age,job){
      this.name = name;
      this.age = age;
      this.job = job;
    }

    Person.prototype = {
      constructor:Person,
      sayName:function () {
        this.name
      }
    }

    var person1 = new Person('a',1,'a');
    var person2 = new Person('a',1,'a');
```

## 动态原型模式

```javascript
function Person(name,age,job) {
    this.name = name;
    this.age = age;
    this.job = job;

    if (typeof this.sayName != 'function') {
      Person.prototype.sayName = function (argument) {
        alert(this.name);
      }
    }
  }

  var friend = new Person('a',29,'a');

  friend.sayName();
```

**使用动态原型模式时，不能使用对象字面量重写原型。因为会切断实例与新原型之间的联系。**

## 寄生构造函数模式

```javascript
function Person(name,age,job) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function () {
      alert(this.name);
    }
    return o;
  }

  var friend = new Person("a",29,'bb');
```

```javascript
function SpecialArray() {
    //创建数组
    var values = new Array();
    //添加值
    values.push.apply(values, arguments);
    //添加方法
    values.toPipedString = function() {
        return this.join("|");
    };
    //返回数组
    return values;
}
var colors = new SpecialArray("red", "blue", "green");
alert(colors.toPipedString()); //"red|blue|green"
```

## 稳妥模式

```javascript
function Person(name, age, job) {
    //创建要返回的对象
    var o = new Object();
    //可以在这里定义私有变量和函数
    //添加方法
    o.sayName = function() {
        alert(name);
    };
    //返回对象
    return o;
}
```

与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也 没有什么关系，因此 instanceof 操作符对这种对象也没有意义。

# 继承

ECMAScript只支持实现继承,即继承实际的方法。而且其实实现继承主要依靠原型链来实现的。

## 原型链

原型链基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。每个构造函数都有一个原型对象,原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么,假如我们让原型对象等于另一个类型的实例。显然此时的原型对象将包含一个指向另一个原型的指针。相应地,另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。

```javascript
function superType() {
    this.property = true;
  }

  superType.prototype.getSuperValue = function () {
    return this.property;
  }

  function SubType(){
    this.subProperty = false;
  }

  SubType.prototype = new superType();
  SubType.prototype.getSubValue = function () {
    return this.subProperty;
  }

  var instance = new SubType();
  alert(instance.getSubValue()); //true
```

## 确定原型和实例的关系

使用instanceof操作符,只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。也可以使用isPrototypeOf()方法,只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型。

## 谨慎地定义方法

子类型有时候需要重写超类型中,给原型添加方法的代码一定要放在替换原型语句之后。

```javascript
function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property;
};

function SubType() {
    this.subproperty = false;
}
//继承了 SuperType
SubType.prototype = new SuperType();
//添加新方法
SubType.prototype.getSubValue = function() {
    return this.subproperty;
};
//重写超类型中的方法
SubType.prototype.getSuperValue = function() {
    return false;
};
var instance = new SubType();
alert(instance.getSuperValue()); //false
```

**还有一点需要提醒读者，即在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这 样做就会重写原型链**

**原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上， 应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。**

**有鉴于此，再加上 前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。**

## 借用构造函数

在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数 （constructor stealing）的技术（有时候也叫做伪造对象或经典继承）函数只不过是在特定环境中执行代码的对象， 因此通过使用 apply()和 call()方法也可以在（将来）新创建的对象上执行构造函数

如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题----方法都在构造函数中定 义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结 果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。

## 组合继承

其背后的思路是使用原型链实现对原型属性和方 法的继承，而通过借用构造函数来实现对实例属性的继承。

```javascript
function superType(name) {
    this.name = name;
    this.colors = ["red","blue","green"];
  }

  superType.prototype.sayName = function () {
    alert(this.name);
  };

  function subType(name,age) {
    superType.call(this,name);
    this.age = age;
  }

  subTyep.prototype = new superType();
  subType.prototype.constructor = subType;
  subTyep.prototype.sayAge = function () {
    console.log(this.age);
  }

  var instance1 = new subType("lee",27);
  instance.colors.push('black');
  console.log(instance1.colors);

  var instance2 = new subType("yi",29);
  console.log(instance2.colors);
```

## 原型式继承

```javascript
function object(o) {
    function F() {}
    F.prototype = o;
    return new F();
  }
```

```javascript
var person = {
    name:'Nicholas',
    friends:['Shelpy','Court','van']
  }

  var anotherPerson = object(person);
  anotherPerson.name = 'Greg';
  anotherPerson.friends.push('Rob');

  var yetAnotherPerson = object(person);
  yetAnotherPerson.name = 'Linda';
  yetAnotherPerson.friends.push('Barbie');

  alert(person.friends);
```

这种原型式继承,要求你必须有一个对象可以作为另一个对象的基础。 ECMAScript5通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数:一个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。

第二个参数与Object.defineProperties()方法的第二个参数格式相同:每个属性都是通过自己的描述符定义的。以这种方式制定的任何属性都会覆盖原型对象上的同名属性。

```javascript
var person = {
    name:'Nicholas',
    friend:['Shelby','Count','Van']
  };

  var anotherPerson = Object.create(person,{
    name:{
      value:'Greg'
    }
  });

  在没有必要兴师动众地创建构造函数,而只是想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。
```

## 寄生式继承

寄生式继承是与原型式继承紧密相关的一种思路

```javascript
function createAnother(original) {
  var clone = object(original);
  clone.sayHi = function () {
    alert('hi');
  }
  return clone;
}
```

## 寄生组合式继承

组合继承最大的问题就是无论什么情况下,都会调用两次超类型构造函数:一次是在创建子类型原型的时候,另一次是在子类型构造函数内部。没错,子类型最终会包含超类型对象的全部实力属性。

```js
  function inheritPrototype(subType,superType) {
    var prototype = object(superType.prototype);
    prototype.constructor = subType;
    subType.prototype = prototype;
  }
```

寄生组合式继承是应用类型最理想的继承范式。
