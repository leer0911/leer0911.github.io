---
title: ECMAScript
---

主要介绍基本类型,对应的转型函数及其规则,操作符对应类型转换规则。

# 变量

ECMAScript的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。

6种基本数据类型:Udefined、Null、Boolean、Number、和String。还有一种复杂数据类型-Object,Object本质上是由一组无序的名值对组成的。由于ECMAScript数据类型具有动态性，因此没有必要再定义别的数据类型。

`[object Object]`代表自定义的对象,第一个object代表用户自定义的对象的属性，第二个Object代表用户自定义的对象的方法。alert出来的对象会隐式调用toString，就变成了`[object Object]`

对变量或值调用 typeof 运算符将返回下列值之一：

- undefined 如果变量是 Undefined 类型的
- boolean 如果变量是 Boolean 类型的
- number 如果变量是 Number 类型的
- string 如果变量是 String 类型的
- object 如果变量是一种引用类型或 Null 类型的
- function 如果这个值是函数

## typeof

**typeof 是一个操作符而不是函数，因此圆括号尽管可以使用，但不是必需的。**

**为什么 typeof 运算符对于 null 值会返回 "Object"。特殊值null被认为是一个空对象引用。这实际上是 JavaScript 最初实现中的一个错误，然后被 ECMAScript 沿用了。现在，null 被认为是对象的占位符，从而解释了这一矛盾，但从技术上来说，它仍然是原始值。**

**Safari 5 及之前版本、 Chrome 7 及之 前版本在对正则表达式调用 typeof 操作符时会返回"function"，而其他浏览器在这种情况下会返回 "object"。**

**对于尚未声明过的变量，只 能执行一项操作，即使用 typeof 操作符检测其数据类型（对未经声明的变量调用 delete 不会导致错 误，但这样做没什么实际意义，而且在严格模式下确实会导致错误）。**

**对未初始化和未声明的变量执行 typeof 操作符都返回了 undefined 值**

## undefined

**即便未初始化的变量会自动被赋予 undefined 值，但显式地初始化变量依然是 明智的选择。如果能够做到这一点，那么当 typeof 操作符返回"undefined"值时， 我们就知道被检测的变量还没有被声明，而不是尚未初始化。**

## Null类型

null 值表 示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回"object"的原因

**如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值。**

这样 一来，只要直接检查 null 值就可以知道相应的变量是否已经保存了一个对象的引用

## Boolean类型

虽然Boolean类型的字面值只有两个，但ECMAScript中所有类型的值都有与这两个Boolean值等价的值。

```
Boolean true | false
String 任何非空字符串 |　空字符串
Number 任何非零数字值(包括无穷大) | 0和NaN
Object 任何对象 | null
Undefined n/a(或 N/A)not applicable  | undefined
```

## Number

浮点数值在某些语言中也被称为双精度数值。所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但不推荐。

由于浮点数需要的内存空间是保存整数值的两倍，因此ECMAScript会不失时机地将浮点数值转换为整数值。

**永远不要测试某个特定的浮点数值**

**由于内存的限制,ECMAScript不能保存世界上所有的数值。**

NaN,即非数值(Not a Number)是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况(这样就不会抛出错误了)。

**NaN与任何值都不相等，包括NaN本身。**

isNaN()在接收到一个值之后,会尝试将找个值转换为数值。某些不是数值的值会直接转换为数值。而任何不能被转换为数值的值都会导致找个函数韩慧true。

**尽管有点儿不可思议，但 isNaN()确实也适用于对象。在基于对象调用 isNaN() 函数时，会首先调用对象的 valueOf()方法，然后确定该方法返回的值是否可以转 换为数值。如果不能，则基于这个返回值再调用 toString()方法，再测试返回值。**

```
Number函数的转换规则:
如果是Boolean值,true和false将分别被转换为1和0。
如果是数字值，只是简单的传入和返回。
如果是null值，返回0。
如果是undefined,返回NaN。
如果是字符串,则遵循以下规则:
 如果字符串中只包含数字,则将其转换为十进制数值。
 如果字符串中包含有效的浮点格式，则将其转换为对应的浮点数值。
 如果字符串中包含有效的十六进制格式，列如"0xf"则转换为对应大小的十进制整数。
 如果字符串是空(不包含任何字符),则将其转换为0。
 如果字符串中包含除上述格式之外字符，则将其转换为NaN。
如果是对象,则调用对象的valueOf()方法,然后依照前面的规则转换返回的值。如果转换的结果是NaN,则调用对象的toString()方法，任何再次转换返回的字符串值。
```

用parseInt()转换空字符串会返回NaN(Number()对空字符串返回0)。在转"22.5"时会被转换为22,因为小数点并不是有效的数字字符

**如果第一个字符不是数字字符或者负号， parseInt() 就会返回 NaN；如果第一个字符是数字字符， parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了 一个非数字字符。**

在 ECMAScript 3 JavaScript 引擎中， "070"被当成八进制字面量，因此转换后的值是十进制的 56。 而在 ECMAScript 5 JavaScript 引擎中， parseInt()已经不具有解析八进制值的能力，因此前导的零会 被认为无效，从而将这个值当成"70"，结果就得到十进制的 70。在 ECMAScript 5 中，即使是在非严格 模式下也会如此。

为了消除在使用 parseInt()函数时可能导致的上述困惑，可以为这个函数提供第二个参数：转换 时使用的基数（即多少进制）。如果知道要解析的值是十六进制格式的字符串，那么指定基数 16 作为第 二个参数，可以保证得到正确的结果，例如：

```javascript
var num = parseInt("0xAF", 16); //175
  var num1 = parseInt("AF", 16); //175
  var num2 = parseInt("AF"); //NaN
```

不指定基数意味着让 parseInt()决定如何解析输入的字符串，因此为了避免错误的解析，我们建 议无论在什么情况下都明确指定基数。

**多数情况下，我们要解析的都是十进制数值，因此始终将 10 作为第二个参数是 非常必要的。**

parseFloat()也是从第一个字符（位置 0）开始解析每个字符。而且 也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。

parseFloat()与 parseInt()的第二个区别在于它始终都会忽略前导 的零。 parseFloat()可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格 式的字符串则始终会被转换成 0。由于 parseFloat()只解析十进制值，因此它没有用第二个参数指定基 数的用法。最后还要注意一点：如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后 都是零） ， parseFloat()会返回整数。以下是使用 parseFloat()转换数值的几个典型示例。

```javascript
var num1 = parseFloat("1234blue"); //1234 （整数）
var num2 = parseFloat("0xA"); //0
var num3 = parseFloat("22.5"); //22.5
var num4 = parseFloat("22.34.5"); //22.34
var num5 = parseFloat("0908.5"); //908.5
var num6 = parseFloat("3.125e7"); //31250000
```

## String类型

String类型用于表示零或多个16位Unicode字符组成的字符序列，即字符串。

### 字符字面量

String数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或者具有其他用途的字符。

```javascript
\n 换行
\t 制表
\b 空格
\r 回车
\f 进纸
\\ 斜杠
\' 单引号（'），在用单引号表示的字符串中使用。例如： 'He said, \'hey.\''
\" 双引号（"），在用双引号表示的字符串中使用。例如： "He said, \"hey.\""
\xnn 以十六进制代码nn表示的一个字符（其中n为0～F）。例如， \x41表示"A"
\unnnn 以十六进制代码nnnn表示的一个Unicode字符（其中n为0～F）。例如， \u03a3表示希腊字符Σ
```

### 字符串的特点

ECMAScript中的字符串是不可变得，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。

### 转换为字符串

要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的toString()方法

数值、布尔值、对象和字符串值（没错，每个字符串也都有一个 toString()方法，该方法返回字 符串的一个副本）都有 toString()方法。但 null 和 undefined 值没有这个方法。

在调用数值的 toString()方法时，可 以传递一个参数：输出数值的基数。默认情况下， toString()方法以十进制格式返回数值的字符串表 示。而通过传递基数， toString()可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格 式表示的字符串值。

在不知道要转换的值是不是 null 或 undefined 的情况下，还可以使用转型函数 String()，这个 函数能够将任何类型的值转换为字符串。 String()函数遵循下列转换规则：

```javascript
如果值有 toString()方法，则调用该方法（没有参数）并返回相应的结果；
  如果值是 null，则返回"null"；
  如果值是 undefined，则返回"undefined"。
```

**要把某个值转换为字符串，可以使用加号操作符（3.5 节讨论）把它与一个字符 串（""）加在一起。**

## Object类型

ECMAScript中的对象其实就是一组数据和功能的集合。

Object的每个实例都具有下列属性和方法。

```javascript
var o = new Object();
```

```
 constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）
就是 Object()。
 hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例
的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例
如： o.hasOwnProperty("name")）。
 isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型（第 5 章将讨论原
型） 。
 propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用 for-in 语句
（本章后面将会讨论）来枚举。与 hasOwnProperty()方法一样，作为参数的属性名必须以字符
串形式指定。
 toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
 toString()：返回对象的字符串表示。
 valueOf()：返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值
相同。
```

从技术角度讲， ECMA-262 中对象的行为不一定适用于 JavaScript 中的其他对象。 浏览器环境中的对象，比如 BOM 和 DOM 中的对象，都属于宿主对象，因为它们是 由宿主实现提供和定义的。 ECMA-262 不负责定义宿主对象，因此宿主对象可能会也 可能不会继承 Object。

## 操作符

只能操作一个值的操作符叫做一元操作符。递增++,递减--,一元加,一元减。

位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。

布尔操作符

逻辑非操作符遵循下列规则:

```
如果操作数是一个对象,返回false;
  如果操作数是一个空字符串,返回true;
  如果操作数是一个非空字符串,返回false;
  如果操作数是数值0,返回true;
  如果操作数是任意非0数值(包括Infinity),返回false;
  如果操作数是null,返回true;
  如果操作数是NaN,返回true;
  如果操作数是undefined,返回true;
```

**同时使用两个非操作符,将模拟Boolean()转型函数的行为。**

逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况 下，逻辑与操作就不一定返回布尔值；此时，它遵循下列规则：

```
 如果第一个操作数是对象，则返回第二个操作数；
 如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该
对象；
 如果两个操作数都是对象，则返回第二个操作数；
 如果有一个操作数是 null，则返回 null；
 如果有一个操作数是 NaN，则返回 NaN；
 如果有一个操作数是 undefined，则返回 undefined。
```

逻辑与属于短路操作，即如果第一个操作数能决定结果，那么久不会再对第二个操作数求值。

逻辑或规则:

```
 如果第一个操作数是对象，则返回第一个操作数；
 如果第一个操作数的求值结果为 false，则返回第二个操作数；
 如果两个操作数都是对象，则返回第一个操作数；
 如果两个操作数都是 null，则返回 null；
 如果两个操作数都是 NaN，则返回 NaN；
 如果两个操作数都是 undefined，则返回 undefined。
```

乘性操作符:乘法,除法,求模。操作数为非数值的情况下会执行自动的类型转换

乘法操作符特殊规则:

```
 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而
如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了 ECMAScript 数值的表示范围，
则返回 Infinity 或-Infinity；
 如果有一个操作数是 NaN，则结果是 NaN；
 如果是 Infinity 与 0 相乘，则结果是 NaN；
 如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或-Infinity，取决于有符号操作数
的符号；
 如果是 Infinity 与 Infinity 相乘，则结果是 Infinity；
 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的
规则。
```

除法操作符规则:

```
 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而
如果只有一个操作数有符号，那么结果就是负数。如果商超过了 ECMAScript 数值的表示范围，
则返回 Infinity 或-Infinity；
 如果有一个操作数是 NaN，则结果是 NaN；
 如果是 Infinity 被 Infinity 除，则结果是 NaN；
 如果是零被零除，则结果是 NaN；
 如果是非零的有限数被零除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；
 如果是 Infinity 被任何非零数值除，则结果是 Infinity 或-Infinity，取决于有符号操作
数的符号；
 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。
```

与另外两个乘性操作符类似，求模操作符会遵循下列特殊规则来处理特殊的值：

```
 如果操作数都是数值，执行常规的除法计算，返回除得的余数；
 如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN；
 如果被除数是有限大的数值而除数是零，则结果是 NaN；
 如果是 Infinity 被 Infinity 除，则结果是 NaN；
 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；
 如果被除数是零，则结果是零；
 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。
```

加性操作符:加法和减法。 如果两个操作符都是数值,执行常规的加法计算,然后根据下列规则返回结果:

```
 如果有一个操作数是 NaN，则结果是 NaN；
 如果是 Infinity 加 Infinity，则结果是 Infinity；
 如果是-Infinity 加-Infinity，则结果是-Infinity；
 如果是 Infinity 加-Infinity，则结果是 NaN；
 如果是+0 加+0，则结果是+0；
 如果是0 加0，则结果是0；
 如果是+0 加0，则结果是+0。
```

不过，如果有一个操作数是字符串，那么就要应用如下规则：

```
 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；
 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接
起来。
```

如果有一个操作数是对象、数值或布尔值，则调用它们的 toString()方法取得相应的字符串值， 然后再应用前面关于字符串的规则。对于 undefined 和 null，则分别调用 String()函数并取得字符 串"undefined"和"null"。

减法操作数遵循一些特殊规则:

```
 如果两个操作符都是数值，则执行常规的算术减法操作并返回结果；
 如果有一个操作数是 NaN，则结果是 NaN；
 如果是 Infinity 减 Infinity，则结果是 NaN；
 如果是-Infinity 减-Infinity，则结果是 NaN；
 如果是 Infinity 减-Infinity，则结果是 Infinity；
 如果是-Infinity 减 Infinity，则结果是-Infinity；
 如果是+0 减+0，则结果是+0；
 如果是+0 减0，则结果是0；
 如果是0 减0，则结果是+0；
 如果有一个操作数是字符串、布尔值、 null 或 undefined，则先在后台调用 Number()函数将
其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果
就是 NaN；
 如果有一个操作数是对象，则调用对象的 valueOf()方法以取得表示该对象的数值。如果得到
的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf()方法，则调用其 toString()
方法并将得到的字符串转换为数值。
```

关系操作符使用了非数值时,也要进行数据转换或完成某些奇怪的操作,以下是响应的规则:

```
 如果两个操作数都是数值，则执行数值比较。
 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。
 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。
 如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执
行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面
的规则执行比较。
 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。
```

**如果要真正按字母表顺序比较字符串，就必须把两个操作数转换为相同的大 小写形式（全部大写或全部小写），然后再执行比较**

相等和不相等----先转换再比较， 全等和不 全等----仅比较而不转换。

在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：

```
 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为 0，而
true 转换为 1；
 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；
 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类
型值按照前面的规则进行比较；
这两个操作符在进行比较时则要遵循下列规则。
 null 和 undefined 是相等的。
 要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。
 如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。重要提示：
即使两个操作数都是 NaN，相等操作符也返回 false；因为按照规则， NaN 不等于 NaN。
 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，
则相等操作符返回 true；否则，返回 false。
```

每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示：

```
 乘/赋值（*=）；
 除/赋值（/=）；
 模/赋值（%=）；
 加/赋值（+=）；
 减/赋值（=）；
 左移/赋值（<<=）；
 有符号右移/赋值（>>=）；
 无符号右移/赋值（>>>=）
```

使用逗号操作符可以在一条语句中执行多个操作，如下面的例子所示：

```javascript
var num1=1, num2=2, num3=3;
```

do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。 换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。以下是 do-while 语句的 语法：

```javascript
do {
    statement
} while (expression);
下面是一个示例：
var i = 0;
do {
    i += 2;
} while (i < 10);
alert(i)
```

while 语句属于前测试循环语句， 也就是说， 在循环体内的代码被执行之前，就会对出口条件求值。 因此，循环体内的代码有可能永远不会被执行。以下是 while 语句的语法：

```javascript
var i = 0;
while (i < 10) {
  i += 2;
}
```

for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。以下是 for-in 语句的语法：

```javascript
for (property in expression) statement
下面是一个示例：
for (var propName in window) {
    document.write(propName);
}
```

**switch 语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如， 字符串"10"不等于数值 10）。**

严格模式对函数有一些限制：
```
 不能把函数命名为 eval 或 arguments；
 不能把参数命名为 eval 或 arguments；
 不能出现两个命名参数同名的情况。
```
如果发生以上情况，就会导致语法错误，代码无法执行

**ECMAScript 中的参数在内部是用一个数组来表示的。函数接收 到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）**

实际上，在函数体内可以通过 arguments 对象来 访问这个参数数组，从而获取传递给函数的每一个参数。

其实， arguments 对象只是与数组类似（它并不是 Array 的实例），因为可以使用方括号语法访
问它的每一个元素（即第一个元素是` arguments[0]`，第二个元素是 `argumetns[1]`，以此类推），使
用 length 属性来确定传递进来多少个参数。

**另一个与参数相关的重要方面，就是 arguments 对象可以与命名参数一起使用**

没有传递值的命名参数将自动被赋予 undefined 值。这就跟定义了
变量但又没有初始化一样。例如，如果只给 doAdd()函数传递了一个参数，则 num2 中就会保存
undefined 值。

**ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。**

**由于不存在函数签名的特性， ECMAScript 函数不能重载。**
