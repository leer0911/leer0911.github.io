---
title: 引用类型
---

引用类型的值(对象)是引用类型的一个实例,引用类型是一种数据结构。用于将数据和功能组织在一起。也常被称为类,但这种称呼并不妥当。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。

# Object类型

Object实例虽然不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。

创建Object实例的方式有两种。第一种是使用new操作符后跟Object构造函数:

```js
  var o = new Object();
  o.name = 'tom';
  o.age = 123;
  console.log(o);
```

另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式。目的是简化创建包含大量属性的对象的过程。

```js
  var person = {
    name : "Nicholas",
    age:29
  };
```

**ECMAScript 中的表达式上下文指的是能够返回一个值（表达式）。赋值操作 符表示后面是一个值，所以左花括号在这里表示一个表达式的开始。同样的花括号，如果出现在一个 语句上下文（statement context）中，例如跟在 if 语句条件的后面，则表示一个语句块的开始。**

**访问对象属性时使用的都是点表示法,不过， 在 JavaScript 也可以使用方括号表示法来访问对象的属性。在使用方括号语法时，应该将要访问的属性 以字符串的形式放在方括号中**

# Array类型

创建数组的基本方式有两种。第一种是使用Array构造函数,第二种基本方式是使用数字字面量表示法。数组字母两是由一对包含数组项的方括号表示，多个数组项之间以逗号隔开。

instanceof操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那么实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。

为了解决这个问题,ECMAScript5新增了Array.isArray()方法。这个方法的目的最终是确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。

```js
  if(Array.isArray(value)){
    //对数组执行某些操作
  }
```

**如果数组中的某一项的值是 null 或者 undefined，那么该值在 join()、 toLocaleString()、 toString()和 valueOf()方法返回的结果中以空字符串表示。**

# Function类型

函数通常是使用函 数声明语法定义的,也可以使用函数表达式的方式，最后一种是使用Function构造函数(可以传递任意参数,最后一个参数作为函数体。缺点是解析时会解析两次,一次是常规 ECMAScript代码,第二次是解析传入构造函数中的字符串)。

**函数是对象,函数名是指针**

**函数声明可以声明提前,而函数表达式则不可以。**

因为 ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。

函数内部有两个特殊对象:arguements和this。arguements的主要用于是保存函数参数。但这个对象还有一个名叫callee的属性,该属性是一个指针，指向拥有这个arguments对象的函数。

函数内部另一个特殊的对象是this,this引用的是函数据以执行的环境对象，或者也可以说是this值。

**函数名仅仅是一个包含指针的变量而已,即使是在不同的环境中执行，指向仍然是同一个函数**

caller保存着调用当前函数的函数的引用,如果是在全局作用域中调用当前函数，它的值为null。

每个函数都包含两个属性:length和prototype。对于 ECMAScript中引用类型而言，prototype是保存它们所有实例方法的真正所在。

在 ECMAScript5中,prototype属性是不可枚举的，因此使用for-in无法发现。

apply和call这两个方法用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。

apply和call真正的用武之地在于能够扩充函数赖以运行的作用域。

# 基本包装类型

为了便于操作基本类型值, ECMAScript还提供了3个特殊的引用类型:Boolean,Number和String。

每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我妈能够调用一些方法来操作这些数据。

在读取模式中访问字符串时,后台都会自动完成下列处理。
- 创建String类型的一个实例;
- 在实例上调用指定的方法;
- 销毁这个实例。

相当于执行了:

```js
  var s1 = new String("some text");
  var s2 = s1.substring(2);
  s1 = null;
```

引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象,则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能再运行时为基本类型值添加属性和方法。

可以显示地调用Boolean、Number和String来创建基本包装类型的对象。不过，应该在绝对必要的情况下再这样做，因为这种做法很容易让人分布清自己是在处理基本类型还是引用类型的值。对基本包装类型的实例调用typeof会返回"object",而且所有基本包装类型的对象都会被转换为布尔值true。

# 单体内置对象

内置对象的定义是:ECMAScript实现提供的，不依赖宿主环境的对象，这些对象在 ECMAScript程序执行之前就已经存在了。意思是开发人员不必显示地实例化内置对象，因为它们已经实例化了。

Global(全局)对象可以说是 ECMAScript中最特别的一个对象了，因为不管你从什么角度上看，这个对象都是不存在的。不属于任何洽谈对象的属性和方法,最终都是它的属性和方法。事实上,没有全局变量或全局函数;
