---
title: 变量、作用域和内存问题
---

ECMAScript变量可能包含两种不同数据类型的值:基本类型值和引用类型值。基本类型值指的是简单数据段，而引用类型值指那些可能由多个值构成的对象。

基本数据类型： Undefined、 Null、 Boolean、 Number 和 String。这 5 种基本数据类型是按值访问 的，因为可以操作保存在变量中的实际的值。

引用类型的值是保存在内存中的对象。与其他语言不同， JavaScript 不允许直接访问内存中的位置， 也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。 为此，引用类型的值是按引用访问的。

**我们不能给基本类型的值添加属性，尽管这样做不会导致任何错误。**

# 传递参数

ECMAScript 中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参 数，就和把值从一个变量复制到另一个变量一样。

**访问变量有按值和按引用两种方式，而参数只能按值传递。**

```javascript
function addTen(num) {
    num += 10;
    return num;
}
var count = 20;
var result = addTen(count);
alert(count);//20,没有变化
alert(result);//30
```

```js
function setName(obj) {
    obj.name = "Nicholas";
    obj = new Object();
    obj.name = "Greg";
}
var person = new Object();
setName(person);
alert(person.name); //"Nicholas"
```

# 检测类型

**可以把 ECMAScript 函数的参数想象成局部变量。**

如果变量是给定引用类型的实例，那么instanceof操作符就会返回true。所有引用类型的值都是Object的实例。因此,在检测一个引用类型值和Object构造函数时,instanceof操作符始终会返回true。

使用 typeof 操作符检测函数时，该操作符会返回"function"。在 Safari 5 及
之前版本和 Chrome 7 及之前版本中使用 typeof 检测正则表达式时，由于规范的原
因，这个操作符也返回"function"。 ECMA-262 规定任何在内部实现`[[Call]]`方法
的对象都应该在应用 typeof 操作符时返回"function"。由于上述浏览器中的正则
表达式也实现了这个方法，因此对正则表达式应用 typeof 会返回"function"。在
IE 和 Firefox 中，对正则表达式应用 typeof 会返回"object"。

# 执行环境及作用域

执行环境定义了变量或函数有权访问其他数据,决定了他们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。

全局执行环境是最外围的一个执行环境。根据 ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。某个执行环境中的所有代码执行完毕后，该环境被销毁。全局环境在应用程序退出时才被销毁。

当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出返回把控制权返回给之前的执行环境。

当代码在一个环境中执行时，会创建变量对象的一个作用域链。其用途是保证对执行环境有权访问的所有变量和函数的有序访问。

**作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。**

标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，
然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）

**函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。**

# 延长作用域链

虽然执行环境的类型总共只有两种:全局和局部(函数)但还是有其他办法来延长作用域链。
这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移
除。在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会
得到加长：
```
 try-catch 语句的 catch 块；
 with 语句。
```

当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什
么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到
了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上
搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味
着该变量尚未声明。

# 垃圾收集
JavaScript具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存。

函数执行过程会为局部变量在栈(或堆)内存上分配相应的空间，以便存储他们的值。

JavaScript中最常用的垃圾收集方式是标记清除。另一种不常见的垃圾收集策略是引用计数。

**确保占用最少的内存可以让页面获得更好的性能。**

而优化内存占用的最佳方式，就是为执行 中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个 做法叫做解除引用（dereferencing）。

```js
function createPerson(name) {
    var localPerson = new Object();
    localPerson.name = name;
    return localPerson;
}
var globalPerson = createPerson("Nicholas");
// 手工解除 globalPerson 的引用
globalPerson = null;
```
