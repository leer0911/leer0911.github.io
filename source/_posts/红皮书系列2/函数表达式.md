---
title: 函数表达式
---

# 特征

定义函数的方式有两种:一种是函数声明,另一种是函数表达式。

函数声明的重要特征是函数声明提升。匿名函数有时候也叫拉姆达函数。

```javascript
function factorial(num) {
    if (num<=1) {
      return 1;
    } else{
      return num * arguments.callee(num-1);
    }
  }
```

# 闭包

匿名函数和闭包并不一样,闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式,就是在函数内部创建另一个函数。

```javascript
function createComparisonFunction(propertyName) {
    return function (object1,object2) {
      var value1 = object1[propertyName];
      var value2 = object2[propertyName];

      if (value1 < value2) {
        return -1;
      } else if(value1>value2){
        return 1
      } else{
        return 0
      }
    };
  }
```

当某个函数被调用时,会创建一个执行环境及相应的作用域。然后,使用arguments和其他命名参数的值来初始化函数的活动对象(activation object)。但在作用域链中，外部函数的活动对象始终处于第二位。...直至作用域链终点的全局执行环境。

在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。后台的每个执行环境都有一个表示变量的对象:变量对象。全局环境的变量对象始终存在，而某个执行函数内部的局部环境的变量对象,则只在函数执行的过程中存在。在创建函数时,会创建一个预先包含全局变量对象的作用域链,这个作用域链被保存在内部的`[[Scope]]`属性中。当调用函数时，会为函数创建一个执行环境,任何通过赋值函数的`[[Scope]]`属性中的对象构建起执行环境的作用域链。此后,又有一个活动对象(在此作为变量对象使用)被创建并推入执行环境作用域的前端。

**作用域链本质上是一个指向变量独享的指针列表，它只引用但不实际包含变量对象。**

一般来讲,当函数执行完毕后，局部活动对象就会被销毁。内存中仅保存全局作用域链(全局执行环境的变量对象)。

在另一个函数内部定义的函数会将包含函数(即外部函数)的活动对象添加到它的作用域链中。

由于闭包会携带包含它的函数的作用域,因此会比其他函数占用更多的内存。

# 闭包和变量

作用域链的这种配置机制引出了一个值得注意的副作用。即闭包只能取得包含函数中任何变量的最后一个值。闭包保存的是整个变量对象,而不是某个特殊的变量。

```javascript
function createFunctions() {
    var result = new Array();

    for (var i = 0; i < 10; i++) {
      result[i] = function (argument) {
        return i;
      };
    }

    return result;
  }

  // 解决方法:

  function createFunctions() {
    var result = new Array();
    for (var i = 0; i < 10; i++) {
      result[i] = function (num) {
        return function () {
          return num;
        };
      }(i);
    }
    return result;
  }
```

# 关于this对象

this对象是在运行时基于函数的执行环境绑定的。在全局函数中,this等于window,而当函数被作为某个对象的方法调用时,this等于那个对象。匿名函数的执行环境具有全局性，因此其this对象通常指向window。

```javascript
var name = 'The Window';

  var object = {
    name:'My Object',
    getNameFunc: function () {
      return function () {
        return this.name
      }
    }
  }

  // var that = this;
```

this和argument也存在同样的问题。如果想访问作用域中argument对象,必须将对该对象的引用保存到另一个闭包能够访问的变量中。

# 内存泄漏

如果闭包的作用域保存着一个HTML元素,那么意味着该元素将无法被销毁。

```javascript
function assignHandler() {
    var element = document.getElementById(*someElement*);
    element.onclick = function () {
      alert(element.id);
    }
  }
```

由于匿名函数保存了一个对assignHandler的活动对象的引用，因此就会导致无法减少element的引用数。element的引用数至少也是1。因此它所占用的内存就永远不会被回收。解决方案:

```javascript
function assignHandler() {
    var ele = document.getElementById("someElement");
    var id = element.id;

    element.onclick = function () {
      alert(id);
    };

    ele = null;
  }
```

在上面的代码中，通过把 element.id 的一个副本保存在一个变量中，并且在闭包中引用该变量消 除了循环引用。但仅仅做到这一步，还是不能解决内存泄漏的问题。必须要记住：闭包会引用包含函数 的整个活动对象，而其中包含着 element。即使闭包不直接引用 element，包含函数的活动对象中也 仍然会保存一个引用。因此，有必要把 element 变量设置为 null。这样就能够解除对 DOM 对象的引 用，顺利地减少其引用数，确保正常回收其占用的内存。

# 块级作用域

```javascript
(function () {
    //这里是块级作用域
  })();
```

将函数声明包含在一对圆括号中,表示它实际上是一个函数表达式。而紧随其后的另一对括号会立即调用这个函数。

无论在上面地方,只要临时需要一些变量，就可以使用私有作用域。

# 私有变量

JavaScript中没有私有成员的概念;所有对象属性都是公有的。私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。利用闭包通过自己的作用域链也可以访问这些变量。而利用这点，就可以创建用于访问私有变量的公有方法。

我们把有权访问私有变量和私有函数的公有方法称为特权方法。有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法:

```js
  function MyObject() {
    //私有变量和私有函数
    var privateVariable = 10;
    function privateFunction() {
      return false;
    }

    this.publickMethod = function () {
      privateVariable++;
      return privateFunction();
    };
  }
```

构造函数中定义特权方法有个缺点:就是必须使用构造函数模式来达到这个目的。构造函数模式的缺点是针对每个实例都会创建同一组新方法。

# 静态私有变量

通过在私有作用域中定义私有变量或函数,同样也可以创建特权方法:
```js
(function() {
    //私有变量和私有函数
    var privateVariable = 10;

    function privateFunction() {
        return false;
    }
    //构造函数
    MyObject = function() {};
    //公有/特权方法
    MyObject.prototype.publicMethod = function() {
        privateVariable++;
        return privateFunction();
    };
})();
```

# 模块模式

之前的模式是用于为自定义类型创建私有变量和特权方法的。模块模式则是为单例创建私有变量和特权方法。所谓单例,指的就是只有一个实例的对象。按照惯例,JavaScript是以对象字面量的方式来创建单例对象的。

```js
var singleton = {
  name:value,
  method: function () {

  }
}
```

```js
var singleton = function () {
  var privateVariable = 10;
  function privateFunction() {
    return false;
  }

  return {
    publicProperty:true,
    publicMethod: function () {
      privateVariable++;
      return privateFunction();
    }
  }
}
```

# 增强模块模式

```js
var singleton = function() {
    //私有变量和私有函数
    var privateVariable = 10;

    function privateFunction() {
        return false;
    }
    //创建对象
    var object = new CustomType();
    //添加特权/公有属性和方法
    object.publicProperty = true;
    object.publicMethod = function() {
        privateVariable++;
        return privateFunction();
    };
    //返回这个对象
    return object;
}();
```
